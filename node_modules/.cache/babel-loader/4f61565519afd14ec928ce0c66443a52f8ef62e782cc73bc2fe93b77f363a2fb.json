{"ast":null,"code":"// src/components/game-logic.js\n\n/**\r\n * Initializes the game state, including shuffling the deck and dealing cards.\r\n * @returns {object} The initial game state.\r\n */\nexport const initializeGame = () => {\n  const suits = ['♠', '♥', '♦', '♣'];\n  const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];\n  let deck = [];\n  for (const suit of suits) {\n    for (const rank of ranks) {\n      deck.push({\n        suit,\n        rank,\n        value: rankValue(rank)\n      });\n    }\n  }\n  deck = shuffleDeck(deck);\n  const playerHands = [[], []];\n  for (let i = 0; i < 10; i++) {\n    playerHands[0].push(deck.pop());\n    playerHands[1].push(deck.pop());\n  }\n  return {\n    deck,\n    playerHands,\n    tableCards: [],\n    playerCaptures: [[], []],\n    currentPlayer: 0,\n    round: 1,\n    scores: [0, 0],\n    gameOver: false,\n    winner: null\n  };\n};\n\n/**\r\n * Shuffles the deck of cards.\r\n * @param {Array} deck - The deck to shuffle.\r\n * @returns {Array} The shuffled deck.\r\n */\nexport const shuffleDeck = deck => {\n  for (let i = deck.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [deck[i], deck[j]] = [deck[j], deck[i]];\n  }\n  return deck;\n};\n\n/**\r\n * Converts a card's rank to its numeric value.\r\n * @param {string} rank - The rank of the card (e.g., 'A', '5', 'K').\r\n * @returns {number} The numeric value of the rank.\r\n */\nexport const rankValue = rank => {\n  if (rank === 'A') return 1;\n  if (rank === 'J') return 11;\n  if (rank === 'Q') return 12;\n  if (rank === 'K') return 13;\n  return parseInt(rank, 10);\n};\n\n/**\r\n * Logs the current state of the game for debugging purposes.\r\n * @param {string} moveDescription - A description of the move that just occurred.\r\n * @param {object} gameState - The game state to log.\r\n */\nconst logGameState = (moveDescription, gameState) => {\n  // Using console.group to create collapsible log groups for better readability\n  console.group(`%cMove: ${moveDescription}`, 'color: blue; font-weight: bold;');\n  console.log('Table Cards:', JSON.parse(JSON.stringify(gameState.tableCards)));\n  console.log('Player 1 Hand:', JSON.parse(JSON.stringify(gameState.playerHands[0])));\n  console.log('Player 2 Hand:', JSON.parse(JSON.stringify(gameState.playerHands[1])));\n  console.log('Player 1 Captures:', JSON.parse(JSON.stringify(gameState.playerCaptures[0])));\n  console.log('Player 2 Captures:', JSON.parse(JSON.stringify(gameState.playerCaptures[1])));\n  console.log(`Next turn: Player ${gameState.currentPlayer + 1}`);\n  console.groupEnd();\n};\n\n/**\r\n * Handles trailing a card to the table.\r\n * @param {object} gameState - The current game state.\r\n * @param {object} card - The card to trail.\r\n * @returns {object} The new game state.\r\n */\nconst playerOwnsBuild = (tableCards, currentPlayer) => {\n  return tableCards.some(c => c.type === 'build' && c.owner === currentPlayer);\n};\nconst hasLooseCardOfRank = (tableCards, rank) => {\n  return tableCards.some(c => !c.type && c.rank === rank);\n};\nconst removeCardFromPlayerHand = (playerHands, currentPlayer, card) => {\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === card.rank && c.suit === card.suit);\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n    return newPlayerHands;\n  } else {\n    console.error(\"Card to trail not found in player's hand.\");\n    return null;\n  }\n};\nexport const handleTrail = (gameState, card) => {\n  const {\n    playerHands,\n    tableCards,\n    currentPlayer,\n    round\n  } = gameState;\n  if (round === 1 && playerOwnsBuild(tableCards, currentPlayer)) {\n    alert(\"You cannot trail a card while you own a build in the first round. You must capture or build.\");\n    return gameState; // Invalid move\n  }\n  if (hasLooseCardOfRank(tableCards, card.rank)) {\n    alert(`You cannot trail a ${card.rank} because one is already on the table.`);\n    return gameState; // Invalid move, return original state.\n  }\n  const newPlayerHands = removeCardFromPlayerHand(playerHands, currentPlayer, card);\n  if (!newPlayerHands) {\n    return gameState; // Card not found, abort.\n  }\n  const newState = {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: [...tableCards, card],\n    currentPlayer: (currentPlayer + 1) % 2\n  };\n  logGameState(`Player ${currentPlayer + 1} trailed a ${card.rank}`, newState);\n  return newState;\n};\n\n/**\r\n * Handles creating a build.\r\n * @param {object} gameState - The current game state.\r\n * @param {object} playerCard - The card played from the hand.\r\n * @param {Array} tableCardsInBuild - The cards from the table to include in the build.\r\n * @param {number} buildValue - The target value of the build.\r\n * @returns {object} The new game state.\r\n */\nconst validateBuild = (playerHand, playerCard, buildValue, tableCards, currentPlayer) => {\n  const canCaptureBuild = playerHand.some(c => rankValue(c.rank) === buildValue && (c.rank !== playerCard.rank || c.suit !== playerCard.suit));\n  if (!canCaptureBuild) {\n    alert(`Cannot build ${buildValue}. You do not have a card of this value to capture it later.`);\n    return false;\n  }\n  const opponentHasSameBuild = tableCards.some(item => item.type === 'build' && item.owner !== currentPlayer && item.value === buildValue);\n  if (opponentHasSameBuild) {\n    alert(`You cannot create a build of ${buildValue} because your opponent already has one.`);\n    return false;\n  }\n  return true;\n};\nconst isValidBuildType = (allCardsInBuild, buildValue) => {\n  const sumOfCards = allCardsInBuild.reduce((sum, card) => sum + rankValue(card.rank), 0);\n  const isSumBuild = sumOfCards === buildValue;\n  const isSetBuild = allCardsInBuild.every(c => rankValue(c.rank) === buildValue);\n  return (isSumBuild || isSetBuild) && buildValue <= 10;\n};\nconst createNewBuild = (playerCard, tableCardsInBuild, buildValue, currentPlayer) => {\n  const allCardsInBuild = [playerCard, ...tableCardsInBuild];\n  allCardsInBuild.sort((a, b) => rankValue(b.rank) - rankValue(a.rank));\n  if (!isValidBuildType(allCardsInBuild, buildValue)) {\n    alert(`Invalid build. Cards do not form a valid build of ${buildValue}.`);\n    return null;\n  }\n  return {\n    buildId: `build-${Date.now()}-${Math.random()}`,\n    type: 'build',\n    cards: allCardsInBuild,\n    value: buildValue,\n    owner: currentPlayer\n  };\n};\nconst removeCardFromHand = (playerHands, currentPlayer, cardToRemove) => {\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === cardToRemove.rank && c.suit === cardToRemove.suit);\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  } else {\n    console.error(\"Played card not found in hand.\");\n    return null;\n  }\n  return newPlayerHands;\n};\nconst removeCardsFromTable = (tableCards, cardsToRemove) => {\n  const identifiers = cardsToRemove.map(c => `${c.rank}-${c.suit}`);\n  return tableCards.filter(c => {\n    if (c.type === 'build') {\n      return true;\n    }\n    return !identifiers.includes(`${c.rank}-${c.suit}`);\n  });\n};\nconst validateBuildCreation = (playerHand, playerCard, buildValue, tableCards, currentPlayer) => {\n  return validateBuild(playerHand, playerCard, buildValue, tableCards, currentPlayer);\n};\nconst createBuild = (playerCard, tableCardsInBuild, buildValue, currentPlayer) => {\n  return createNewBuild(playerCard, tableCardsInBuild, buildValue, currentPlayer);\n};\nconst updatePlayerHandsAfterBuild = (playerHands, currentPlayer, playerCard) => {\n  return removeCardFromHand(playerHands, currentPlayer, playerCard);\n};\nconst updateTableCardsAfterBuild = (tableCards, tableCardsInBuild, newBuild) => {\n  const newTableCards = removeCardsFromTable(tableCards, tableCardsInBuild);\n  newTableCards.push(newBuild);\n  return newTableCards;\n};\nexport const handleBuild = (gameState, playerCard, tableCardsInBuild, buildValue) => {\n  const {\n    playerHands,\n    tableCards,\n    currentPlayer\n  } = gameState;\n  const playerHand = playerHands[currentPlayer];\n  if (!validateBuildCreation(playerHand, playerCard, buildValue, tableCards, currentPlayer)) {\n    return gameState;\n  }\n  const newBuild = createBuild(playerCard, tableCardsInBuild, buildValue, currentPlayer);\n  if (!newBuild) {\n    return gameState;\n  }\n  const newPlayerHands = updatePlayerHandsAfterBuild(playerHands, currentPlayer, playerCard);\n  if (!newPlayerHands) {\n    return gameState;\n  }\n  const newTableCards = updateTableCardsAfterBuild(tableCards, tableCardsInBuild, newBuild);\n  const newState = {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    currentPlayer: (currentPlayer + 1) % 2\n  };\n  logGameState(`Player ${currentPlayer + 1} built a ${buildValue}`, newState);\n  return newState;\n};\n\n/**\r\n * Handles adding cards to an existing build.\r\n * @param {object} gameState - The current game state.\r\n * @param {object} playerCard - The card played from the hand.\r\n * @param {object} tableCard - The loose card from the table to add to the build.\r\n * @param {object} buildToAddTo - The build object being modified.\r\n * @returns {object} The new game state.\r\n */\nconst removeCardFromHandIfExists = (playerHands, currentPlayer, cardToRemove) => {\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === cardToRemove.rank && c.suit === cardToRemove.suit);\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  }\n  return newPlayerHands;\n};\nconst removeBuildAndCardFromTable = (tableCards, buildToRemove, looseCardToRemove) => {\n  return tableCards.filter(item => {\n    if (item.buildId === buildToRemove.buildId) return false;\n    if (!item.type && item.rank === looseCardToRemove.rank && item.suit === looseCardToRemove.suit) return false;\n    return true;\n  });\n};\nconst createUpdatedBuild = (buildToAddTo, playerCard, tableCard) => {\n  const newPair = [playerCard, tableCard];\n  newPair.sort((a, b) => rankValue(b.rank) - rankValue(a.rank));\n  const newBuildCards = [...buildToAddTo.cards, ...newPair];\n  return {\n    ...buildToAddTo,\n    cards: newBuildCards\n  };\n};\nconst updatePlayerHandsAfterAddToBuild = (playerHands, currentPlayer, playerCard) => {\n  return removeCardFromHandIfExists(playerHands, currentPlayer, playerCard);\n};\nconst updateTableCardsAfterAddToBuild = (tableCards, buildToAddTo, tableCard, newBuild) => {\n  const newTableCards = removeBuildAndCardFromTable(tableCards, buildToAddTo, tableCard);\n  newTableCards.push(newBuild);\n  return newTableCards;\n};\nexport const handleAddToBuild = (gameState, playerCard, tableCard, buildToAddTo) => {\n  const {\n    playerHands,\n    tableCards,\n    currentPlayer\n  } = gameState;\n  const newBuild = createUpdatedBuild(buildToAddTo, playerCard, tableCard);\n  const newPlayerHands = updatePlayerHandsAfterAddToBuild(playerHands, currentPlayer, playerCard);\n  const newTableCards = updateTableCardsAfterAddToBuild(tableCards, buildToAddTo, tableCard, newBuild);\n  const newState = {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    currentPlayer: (currentPlayer + 1) % 2\n  };\n  logGameState(`Player ${currentPlayer + 1} added to build of ${newBuild.value}`, newState);\n  return newState;\n};\n\n/**\r\n * Finds all valid captures for a given card.\r\n * @param {object} selectedCard - The card selected from the player's hand.\r\n * @param {Array} tableCards - The cards on the table.\r\n * @returns {Array} An array of valid captures.\r\n */\nconst findCombinations = (cards, target) => {\n  const result = [];\n  const find = (startIndex, currentCombination, currentSum) => {\n    if (currentSum === target) {\n      result.push(currentCombination);\n      return;\n    }\n    if (currentSum > target) {\n      return;\n    }\n    for (let i = startIndex; i < cards.length; i++) {\n      find(i + 1, [...currentCombination, cards[i]], currentSum + cards[i].value);\n    }\n  };\n  find(0, [], 0);\n  return result;\n};\nexport const findValidCaptures = (selectedCard, tableCards) => {\n  const validCaptures = [];\n  const cardValue = selectedCard.value;\n\n  // 1. Find all combinations of loose cards that sum up to the card value\n  const looseCards = tableCards.filter(c => c.type !== 'build');\n  const looseCardCombinations = findCombinations(looseCards, cardValue);\n  for (const combination of looseCardCombinations) {\n    validCaptures.push(combination);\n  }\n\n  // 2. Find all builds that can be captured\n  const buildCaptures = tableCards.filter(c => c.type === 'build' && c.value === cardValue);\n  for (const build of buildCaptures) {\n    validCaptures.push([build]);\n  }\n  return validCaptures;\n};\n\n/**\r\n * Finds all valid builds for a given card.\r\n * @param {object} selectedCard - The card selected from the player's hand.\r\n * @param {Array} tableCards - The cards on the table.\r\n * @returns {Array} An array of valid builds.\r\n */\nexport const findValidBuilds = (selectedCard, tableCards) => {\n  const validBuilds = [];\n  const cardValue = selectedCard.value;\n\n  // Find all combinations of loose cards that sum up to the cardValue\n  const looseCards = tableCards.filter(c => c.type !== 'build');\n  const looseCardCombinations = findCombinations(looseCards, cardValue);\n  for (const combination of looseCardCombinations) {\n    validBuilds.push(combination);\n  }\n  return validBuilds;\n};\n\n/**\r\n * Handles capturing cards from the table.\r\n * @param {object} gameState - The current game state.\r\n * @param {object} selectedCard - The card selected from the player's hand.\r\n * @param {Array} selectedTableCards - The cards selected from the table to capture.\r\n * @returns {object} The new game state.\r\n */\nconst removeCardFromHandOrLogError = (playerHands, currentPlayer, cardToRemove) => {\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === cardToRemove.rank && c.suit === cardToRemove.suit);\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  } else {\n    console.error(\"Card to capture with not found in player's hand.\");\n    return null;\n  }\n  return newPlayerHands;\n};\nconst removeCapturedCardsFromTable = (tableCards, selectedTableCards) => {\n  const capturedItemsIdentifiers = new Set(selectedTableCards.map(c => c.buildId ? c.buildId : `${c.rank}-${c.suit}`));\n  return tableCards.filter(item => {\n    if (item.type === 'build') {\n      const isBuildCaptured = selectedTableCards.some(capturedItem => capturedItem.buildId === item.buildId);\n      return !isBuildCaptured;\n    } else {\n      return !capturedItemsIdentifiers.has(`${item.rank}-${item.suit}`);\n    }\n  });\n};\nconst updatePlayerHandsAfterCapture = (playerHands, currentPlayer, selectedCard) => {\n  return removeCardFromHandOrLogError(playerHands, currentPlayer, selectedCard);\n};\nconst updateTableCardsAfterCapture = (tableCards, selectedTableCards) => {\n  return removeCapturedCardsFromTable(tableCards, selectedTableCards);\n};\nconst updatePlayerCapturesAfterCapture = (playerCaptures, currentPlayer, selectedCard, selectedTableCards) => {\n  const newPlayerCaptures = JSON.parse(JSON.stringify(playerCaptures));\n  const capturedGroup = [selectedCard, ...selectedTableCards.flatMap(item => item.type === 'build' ? item.cards : item)];\n  newPlayerCaptures[currentPlayer].push(capturedGroup);\n  return newPlayerCaptures;\n};\nexport const handleCapture = (gameState, selectedCard, selectedTableCards) => {\n  const {\n    playerHands,\n    tableCards,\n    playerCaptures,\n    currentPlayer\n  } = gameState;\n  const newPlayerHands = updatePlayerHandsAfterCapture(playerHands, currentPlayer, selectedCard);\n  if (!newPlayerHands) {\n    return gameState;\n  }\n  const newTableCards = updateTableCardsAfterCapture(tableCards, selectedTableCards);\n  const newPlayerCaptures = updatePlayerCapturesAfterCapture(playerCaptures, currentPlayer, selectedCard, selectedTableCards);\n  const newState = {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    playerCaptures: newPlayerCaptures,\n    currentPlayer: (currentPlayer + 1) % 2\n  };\n  logGameState(`Player ${currentPlayer + 1} captured with a ${selectedCard.rank}`, newState);\n  return newState;\n};\n\n/**\r\n * Calculates the scores for each player.\r\n * @param {Array} playerCaptures - An array of captured cards for each player.\r\n * @returns {Array} An array of scores for each player.\r\n */\nexport const calculateScores = playerCaptures => {\n  const scores = [0, 0];\n\n  // Flatten the captured groups for each player to get a simple list of cards for scoring\n  const flatPlayerCaptures = playerCaptures.map(captureGroups => captureGroups.flat());\n  flatPlayerCaptures.forEach((captures, playerIndex) => {\n    let score = 0;\n    for (const card of captures) {\n      if (card.rank === 'A') {\n        score += 1;\n      } else if (card.rank === '10' && card.suit === '♦') {\n        score += 2;\n      } else if (card.rank === '2' && card.suit === '♠') {\n        score += 1;\n      }\n    }\n    scores[playerIndex] = score;\n  });\n\n  // Add bonus points for the player with the most cards\n  if (flatPlayerCaptures[0].length > flatPlayerCaptures[1].length) {\n    scores[0] += 3;\n  } else if (flatPlayerCaptures[1].length > flatPlayerCaptures[0].length) {\n    scores[1] += 3;\n  }\n  return scores;\n};\n\n/**\r\n * Checks if the round is over.\r\n * @param {object} gameState - The current game state.\r\n * @returns {boolean} True if the round is over, false otherwise.\r\n */\nexport const isRoundOver = gameState => {\n  return gameState.playerHands.every(hand => hand.length === 0);\n};\n\n/**\r\n * Checks if the game is over.\r\n * @param {object} gameState - The current game state.\r\n * @returns {boolean} True if the game is over, false otherwise.\r\n */\nexport const isGameOver = gameState => {\n  return gameState.round === 2 && isRoundOver(gameState);\n};","map":{"version":3,"names":["initializeGame","suits","ranks","deck","suit","rank","push","value","rankValue","shuffleDeck","playerHands","i","pop","tableCards","playerCaptures","currentPlayer","round","scores","gameOver","winner","length","j","Math","floor","random","parseInt","logGameState","moveDescription","gameState","console","group","log","JSON","parse","stringify","groupEnd","playerOwnsBuild","some","c","type","owner","hasLooseCardOfRank","removeCardFromPlayerHand","card","newPlayerHands","hand","cardIndex","findIndex","splice","error","handleTrail","alert","newState","validateBuild","playerHand","playerCard","buildValue","canCaptureBuild","opponentHasSameBuild","item","isValidBuildType","allCardsInBuild","sumOfCards","reduce","sum","isSumBuild","isSetBuild","every","createNewBuild","tableCardsInBuild","sort","a","b","buildId","Date","now","cards","removeCardFromHand","cardToRemove","removeCardsFromTable","cardsToRemove","identifiers","map","filter","includes","validateBuildCreation","createBuild","updatePlayerHandsAfterBuild","updateTableCardsAfterBuild","newBuild","newTableCards","handleBuild","removeCardFromHandIfExists","removeBuildAndCardFromTable","buildToRemove","looseCardToRemove","createUpdatedBuild","buildToAddTo","tableCard","newPair","newBuildCards","updatePlayerHandsAfterAddToBuild","updateTableCardsAfterAddToBuild","handleAddToBuild","findCombinations","target","result","find","startIndex","currentCombination","currentSum","findValidCaptures","selectedCard","validCaptures","cardValue","looseCards","looseCardCombinations","combination","buildCaptures","build","findValidBuilds","validBuilds","removeCardFromHandOrLogError","removeCapturedCardsFromTable","selectedTableCards","capturedItemsIdentifiers","Set","isBuildCaptured","capturedItem","has","updatePlayerHandsAfterCapture","updateTableCardsAfterCapture","updatePlayerCapturesAfterCapture","newPlayerCaptures","capturedGroup","flatMap","handleCapture","calculateScores","flatPlayerCaptures","captureGroups","flat","forEach","captures","playerIndex","score","isRoundOver","isGameOver"],"sources":["C:/Users/LB/Desktop/Linda Baloyi/casino/src/components/game-logic.js"],"sourcesContent":["\r\n// src/components/game-logic.js\r\n\r\n/**\r\n * Initializes the game state, including shuffling the deck and dealing cards.\r\n * @returns {object} The initial game state.\r\n */\r\nexport const initializeGame = () => {\r\n  const suits = ['♠', '♥', '♦', '♣'];\r\n  const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];\r\n  let deck = [];\r\n\r\n  for (const suit of suits) {\r\n    for (const rank of ranks) {\r\n      deck.push({ suit, rank, value: rankValue(rank) });\r\n    }\r\n  }\r\n\r\n  deck = shuffleDeck(deck);\r\n\r\n  const playerHands = [[], []];\r\n  for (let i = 0; i < 10; i++) {\r\n    playerHands[0].push(deck.pop());\r\n    playerHands[1].push(deck.pop());\r\n  }\r\n\r\n  return {\r\n    deck,\r\n    playerHands,\r\n    tableCards: [],\r\n    playerCaptures: [[], []],\r\n    currentPlayer: 0,\r\n    round: 1,\r\n    scores: [0, 0],\r\n    gameOver: false,\r\n    winner: null,\r\n  };\r\n};\r\n\r\n/**\r\n * Shuffles the deck of cards.\r\n * @param {Array} deck - The deck to shuffle.\r\n * @returns {Array} The shuffled deck.\r\n */\r\nexport const shuffleDeck = (deck) => {\r\n  for (let i = deck.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [deck[i], deck[j]] = [deck[j], deck[i]];\r\n  }\r\n  return deck;\r\n};\r\n\r\n/**\r\n * Converts a card's rank to its numeric value.\r\n * @param {string} rank - The rank of the card (e.g., 'A', '5', 'K').\r\n * @returns {number} The numeric value of the rank.\r\n */\r\nexport const rankValue = (rank) => {\r\n  if (rank === 'A') return 1;\r\n  if (rank === 'J') return 11;\r\n  if (rank === 'Q') return 12;\r\n  if (rank === 'K') return 13;\r\n  return parseInt(rank, 10);\r\n};\r\n\r\n/**\r\n * Logs the current state of the game for debugging purposes.\r\n * @param {string} moveDescription - A description of the move that just occurred.\r\n * @param {object} gameState - The game state to log.\r\n */\r\nconst logGameState = (moveDescription, gameState) => {\r\n  // Using console.group to create collapsible log groups for better readability\r\n  console.group(`%cMove: ${moveDescription}`, 'color: blue; font-weight: bold;');\r\n  console.log('Table Cards:', JSON.parse(JSON.stringify(gameState.tableCards)));\r\n  console.log('Player 1 Hand:', JSON.parse(JSON.stringify(gameState.playerHands[0])));\r\n  console.log('Player 2 Hand:', JSON.parse(JSON.stringify(gameState.playerHands[1])));\r\n  console.log('Player 1 Captures:', JSON.parse(JSON.stringify(gameState.playerCaptures[0])));\r\n  console.log('Player 2 Captures:', JSON.parse(JSON.stringify(gameState.playerCaptures[1])));\r\n  console.log(`Next turn: Player ${gameState.currentPlayer + 1}`);\r\n  console.groupEnd();\r\n};\r\n\r\n/**\r\n * Handles trailing a card to the table.\r\n * @param {object} gameState - The current game state.\r\n * @param {object} card - The card to trail.\r\n * @returns {object} The new game state.\r\n */\r\nconst playerOwnsBuild = (tableCards, currentPlayer) => {\r\n  return tableCards.some(c => c.type === 'build' && c.owner === currentPlayer);\r\n};\r\n\r\nconst hasLooseCardOfRank = (tableCards, rank) => {\r\n  return tableCards.some(c => !c.type && c.rank === rank);\r\n};\r\n\r\nconst removeCardFromPlayerHand = (playerHands, currentPlayer, card) => {\r\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\r\n  const hand = newPlayerHands[currentPlayer];\r\n  const cardIndex = hand.findIndex(c => c.rank === card.rank && c.suit === card.suit);\r\n\r\n  if (cardIndex > -1) {\r\n    hand.splice(cardIndex, 1);\r\n    return newPlayerHands;\r\n  } else {\r\n    console.error(\"Card to trail not found in player's hand.\");\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const handleTrail = (gameState, card) => {\r\n  const { playerHands, tableCards, currentPlayer, round } = gameState;\r\n\r\n  if (round === 1 && playerOwnsBuild(tableCards, currentPlayer)) {\r\n    alert(\"You cannot trail a card while you own a build in the first round. You must capture or build.\");\r\n    return gameState; // Invalid move\r\n  }\r\n\r\n  if (hasLooseCardOfRank(tableCards, card.rank)) {\r\n    alert(`You cannot trail a ${card.rank} because one is already on the table.`);\r\n    return gameState; // Invalid move, return original state.\r\n  }\r\n\r\n  const newPlayerHands = removeCardFromPlayerHand(playerHands, currentPlayer, card);\r\n  if (!newPlayerHands) {\r\n    return gameState; // Card not found, abort.\r\n  }\r\n\r\n  const newState = {\r\n    ...gameState,\r\n    playerHands: newPlayerHands,\r\n    tableCards: [...tableCards, card],\r\n    currentPlayer: (currentPlayer + 1) % 2,\r\n  };\r\n\r\n  logGameState(`Player ${currentPlayer + 1} trailed a ${card.rank}`, newState);\r\n  return newState;\r\n};\r\n\r\n/**\r\n * Handles creating a build.\r\n * @param {object} gameState - The current game state.\r\n * @param {object} playerCard - The card played from the hand.\r\n * @param {Array} tableCardsInBuild - The cards from the table to include in the build.\r\n * @param {number} buildValue - The target value of the build.\r\n * @returns {object} The new game state.\r\n */\r\nconst validateBuild = (playerHand, playerCard, buildValue, tableCards, currentPlayer) => {\r\n  const canCaptureBuild = playerHand.some(\r\n    c => rankValue(c.rank) === buildValue && (c.rank !== playerCard.rank || c.suit !== playerCard.suit)\r\n  );\r\n  if (!canCaptureBuild) {\r\n    alert(`Cannot build ${buildValue}. You do not have a card of this value to capture it later.`);\r\n    return false;\r\n  }\r\n\r\n  const opponentHasSameBuild = tableCards.some(\r\n    item => item.type === 'build' && item.owner !== currentPlayer && item.value === buildValue\r\n  );\r\n  if (opponentHasSameBuild) {\r\n    alert(`You cannot create a build of ${buildValue} because your opponent already has one.`);\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst isValidBuildType = (allCardsInBuild, buildValue) => {\r\n  const sumOfCards = allCardsInBuild.reduce((sum, card) => sum + rankValue(card.rank), 0);\r\n  const isSumBuild = sumOfCards === buildValue;\r\n  const isSetBuild = allCardsInBuild.every(c => rankValue(c.rank) === buildValue);\r\n  return (isSumBuild || isSetBuild) && buildValue <= 10;\r\n};\r\n\r\nconst createNewBuild = (playerCard, tableCardsInBuild, buildValue, currentPlayer) => {\r\n  const allCardsInBuild = [playerCard, ...tableCardsInBuild];\r\n  allCardsInBuild.sort((a, b) => rankValue(b.rank) - rankValue(a.rank));\r\n\r\n  if (!isValidBuildType(allCardsInBuild, buildValue)) {\r\n    alert(`Invalid build. Cards do not form a valid build of ${buildValue}.`);\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    buildId: `build-${Date.now()}-${Math.random()}`,\r\n    type: 'build',\r\n    cards: allCardsInBuild,\r\n    value: buildValue,\r\n    owner: currentPlayer,\r\n  };\r\n};\r\n\r\nconst removeCardFromHand = (playerHands, currentPlayer, cardToRemove) => {\r\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\r\n  const hand = newPlayerHands[currentPlayer];\r\n  const cardIndex = hand.findIndex(c => c.rank === cardToRemove.rank && c.suit === cardToRemove.suit);\r\n  if (cardIndex > -1) {\r\n    hand.splice(cardIndex, 1);\r\n  } else {\r\n    console.error(\"Played card not found in hand.\");\r\n    return null;\r\n  }\r\n  return newPlayerHands;\r\n};\r\n\r\nconst removeCardsFromTable = (tableCards, cardsToRemove) => {\r\n  const identifiers = cardsToRemove.map(c => `${c.rank}-${c.suit}`);\r\n  return tableCards.filter(c => {\r\n    if (c.type === 'build') {\r\n      return true;\r\n    }\r\n    return !identifiers.includes(`${c.rank}-${c.suit}`);\r\n  });\r\n};\r\n\r\nconst validateBuildCreation = (playerHand, playerCard, buildValue, tableCards, currentPlayer) => {\r\n  return validateBuild(playerHand, playerCard, buildValue, tableCards, currentPlayer);\r\n};\r\n\r\nconst createBuild = (playerCard, tableCardsInBuild, buildValue, currentPlayer) => {\r\n  return createNewBuild(playerCard, tableCardsInBuild, buildValue, currentPlayer);\r\n};\r\n\r\nconst updatePlayerHandsAfterBuild = (playerHands, currentPlayer, playerCard) => {\r\n  return removeCardFromHand(playerHands, currentPlayer, playerCard);\r\n};\r\n\r\nconst updateTableCardsAfterBuild = (tableCards, tableCardsInBuild, newBuild) => {\r\n  const newTableCards = removeCardsFromTable(tableCards, tableCardsInBuild);\r\n  newTableCards.push(newBuild);\r\n  return newTableCards;\r\n};\r\n\r\nexport const handleBuild = (gameState, playerCard, tableCardsInBuild, buildValue) => {\r\n  const { playerHands, tableCards, currentPlayer } = gameState;\r\n  const playerHand = playerHands[currentPlayer];\r\n\r\n  if (!validateBuildCreation(playerHand, playerCard, buildValue, tableCards, currentPlayer)) {\r\n    return gameState;\r\n  }\r\n\r\n  const newBuild = createBuild(playerCard, tableCardsInBuild, buildValue, currentPlayer);\r\n  if (!newBuild) {\r\n    return gameState;\r\n  }\r\n\r\n  const newPlayerHands = updatePlayerHandsAfterBuild(playerHands, currentPlayer, playerCard);\r\n  if (!newPlayerHands) {\r\n    return gameState;\r\n  }\r\n\r\n  const newTableCards = updateTableCardsAfterBuild(tableCards, tableCardsInBuild, newBuild);\r\n\r\n  const newState = {\r\n    ...gameState,\r\n    playerHands: newPlayerHands,\r\n    tableCards: newTableCards,\r\n    currentPlayer: (currentPlayer + 1) % 2,\r\n  };\r\n\r\n  logGameState(`Player ${currentPlayer + 1} built a ${buildValue}`, newState);\r\n  return newState;\r\n};\r\n\r\n/**\r\n * Handles adding cards to an existing build.\r\n * @param {object} gameState - The current game state.\r\n * @param {object} playerCard - The card played from the hand.\r\n * @param {object} tableCard - The loose card from the table to add to the build.\r\n * @param {object} buildToAddTo - The build object being modified.\r\n * @returns {object} The new game state.\r\n */\r\nconst removeCardFromHandIfExists = (playerHands, currentPlayer, cardToRemove) => {\r\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\r\n  const hand = newPlayerHands[currentPlayer];\r\n  const cardIndex = hand.findIndex(c => c.rank === cardToRemove.rank && c.suit === cardToRemove.suit);\r\n  if (cardIndex > -1) {\r\n    hand.splice(cardIndex, 1);\r\n  }\r\n  return newPlayerHands;\r\n};\r\n\r\nconst removeBuildAndCardFromTable = (tableCards, buildToRemove, looseCardToRemove) => {\r\n  return tableCards.filter(item => {\r\n    if (item.buildId === buildToRemove.buildId) return false;\r\n    if (!item.type && item.rank === looseCardToRemove.rank && item.suit === looseCardToRemove.suit) return false;\r\n    return true;\r\n  });\r\n};\r\n\r\nconst createUpdatedBuild = (buildToAddTo, playerCard, tableCard) => {\r\n  const newPair = [playerCard, tableCard];\r\n  newPair.sort((a, b) => rankValue(b.rank) - rankValue(a.rank));\r\n  const newBuildCards = [...buildToAddTo.cards, ...newPair];\r\n\r\n  return {\r\n    ...buildToAddTo,\r\n    cards: newBuildCards,\r\n  };\r\n};\r\n\r\nconst updatePlayerHandsAfterAddToBuild = (playerHands, currentPlayer, playerCard) => {\r\n  return removeCardFromHandIfExists(playerHands, currentPlayer, playerCard);\r\n};\r\n\r\nconst updateTableCardsAfterAddToBuild = (tableCards, buildToAddTo, tableCard, newBuild) => {\r\n  const newTableCards = removeBuildAndCardFromTable(tableCards, buildToAddTo, tableCard);\r\n  newTableCards.push(newBuild);\r\n  return newTableCards;\r\n};\r\n\r\nexport const handleAddToBuild = (gameState, playerCard, tableCard, buildToAddTo) => {\r\n  const { playerHands, tableCards, currentPlayer } = gameState;\r\n\r\n  const newBuild = createUpdatedBuild(buildToAddTo, playerCard, tableCard);\r\n  const newPlayerHands = updatePlayerHandsAfterAddToBuild(playerHands, currentPlayer, playerCard);\r\n  const newTableCards = updateTableCardsAfterAddToBuild(tableCards, buildToAddTo, tableCard, newBuild);\r\n\r\n  const newState = {\r\n    ...gameState,\r\n    playerHands: newPlayerHands,\r\n    tableCards: newTableCards,\r\n    currentPlayer: (currentPlayer + 1) % 2,\r\n  };\r\n  logGameState(`Player ${currentPlayer + 1} added to build of ${newBuild.value}`, newState);\r\n  return newState;\r\n};\r\n\r\n/**\r\n * Finds all valid captures for a given card.\r\n * @param {object} selectedCard - The card selected from the player's hand.\r\n * @param {Array} tableCards - The cards on the table.\r\n * @returns {Array} An array of valid captures.\r\n */\r\nconst findCombinations = (cards, target) => {\r\n  const result = [];\r\n  const find = (startIndex, currentCombination, currentSum) => {\r\n    if (currentSum === target) {\r\n      result.push(currentCombination);\r\n      return;\r\n    }\r\n    if (currentSum > target) {\r\n      return;\r\n    }\r\n    for (let i = startIndex; i < cards.length; i++) {\r\n      find(i + 1, [...currentCombination, cards[i]], currentSum + cards[i].value);\r\n    }\r\n  };\r\n  find(0, [], 0);\r\n  return result;\r\n};\r\n\r\nexport const findValidCaptures = (selectedCard, tableCards) => {\r\n  const validCaptures = [];\r\n  const cardValue = selectedCard.value;\r\n\r\n  // 1. Find all combinations of loose cards that sum up to the card value\r\n  const looseCards = tableCards.filter((c) => c.type !== 'build');\r\n  const looseCardCombinations = findCombinations(looseCards, cardValue);\r\n  for (const combination of looseCardCombinations) {\r\n    validCaptures.push(combination);\r\n  }\r\n\r\n  // 2. Find all builds that can be captured\r\n  const buildCaptures = tableCards.filter((c) => c.type === 'build' && c.value === cardValue);\r\n  for (const build of buildCaptures) {\r\n    validCaptures.push([build]);\r\n  }\r\n\r\n  return validCaptures;\r\n};\r\n\r\n/**\r\n * Finds all valid builds for a given card.\r\n * @param {object} selectedCard - The card selected from the player's hand.\r\n * @param {Array} tableCards - The cards on the table.\r\n * @returns {Array} An array of valid builds.\r\n */\r\nexport const findValidBuilds = (selectedCard, tableCards) => {\r\n  const validBuilds = [];\r\n  const cardValue = selectedCard.value;\r\n\r\n  // Find all combinations of loose cards that sum up to the cardValue\r\n  const looseCards = tableCards.filter((c) => c.type !== 'build');\r\n  const looseCardCombinations = findCombinations(looseCards, cardValue);\r\n  for (const combination of looseCardCombinations) {\r\n    validBuilds.push(combination);\r\n  }\r\n\r\n  return validBuilds;\r\n};\r\n\r\n/**\r\n * Handles capturing cards from the table.\r\n * @param {object} gameState - The current game state.\r\n * @param {object} selectedCard - The card selected from the player's hand.\r\n * @param {Array} selectedTableCards - The cards selected from the table to capture.\r\n * @returns {object} The new game state.\r\n */\r\nconst removeCardFromHandOrLogError = (playerHands, currentPlayer, cardToRemove) => {\r\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\r\n  const hand = newPlayerHands[currentPlayer];\r\n  const cardIndex = hand.findIndex(c => c.rank === cardToRemove.rank && c.suit === cardToRemove.suit);\r\n\r\n  if (cardIndex > -1) {\r\n    hand.splice(cardIndex, 1);\r\n  } else {\r\n    console.error(\"Card to capture with not found in player's hand.\");\r\n    return null;\r\n  }\r\n  return newPlayerHands;\r\n};\r\n\r\nconst removeCapturedCardsFromTable = (tableCards, selectedTableCards) => {\r\n  const capturedItemsIdentifiers = new Set(selectedTableCards.map(c => c.buildId ? c.buildId : `${c.rank}-${c.suit}`));\r\n  return tableCards.filter(item => {\r\n    if (item.type === 'build') {\r\n      const isBuildCaptured = selectedTableCards.some(capturedItem => capturedItem.buildId === item.buildId);\r\n      return !isBuildCaptured;\r\n    } else {\r\n      return !capturedItemsIdentifiers.has(`${item.rank}-${item.suit}`);\r\n    }\r\n  });\r\n};\r\n\r\nconst updatePlayerHandsAfterCapture = (playerHands, currentPlayer, selectedCard) => {\r\n  return removeCardFromHandOrLogError(playerHands, currentPlayer, selectedCard);\r\n};\r\n\r\nconst updateTableCardsAfterCapture = (tableCards, selectedTableCards) => {\r\n  return removeCapturedCardsFromTable(tableCards, selectedTableCards);\r\n};\r\n\r\nconst updatePlayerCapturesAfterCapture = (playerCaptures, currentPlayer, selectedCard, selectedTableCards) => {\r\n  const newPlayerCaptures = JSON.parse(JSON.stringify(playerCaptures));\r\n  const capturedGroup = [selectedCard, ...selectedTableCards.flatMap(item => item.type === 'build' ? item.cards : item)];\r\n  newPlayerCaptures[currentPlayer].push(capturedGroup);\r\n  return newPlayerCaptures;\r\n};\r\n\r\nexport const handleCapture = (gameState, selectedCard, selectedTableCards) => {\r\n  const { playerHands, tableCards, playerCaptures, currentPlayer } = gameState;\r\n\r\n  const newPlayerHands = updatePlayerHandsAfterCapture(playerHands, currentPlayer, selectedCard);\r\n  if (!newPlayerHands) {\r\n    return gameState;\r\n  }\r\n\r\n  const newTableCards = updateTableCardsAfterCapture(tableCards, selectedTableCards);\r\n  const newPlayerCaptures = updatePlayerCapturesAfterCapture(playerCaptures, currentPlayer, selectedCard, selectedTableCards);\r\n\r\n  const newState = {\r\n    ...gameState,\r\n    playerHands: newPlayerHands,\r\n    tableCards: newTableCards,\r\n    playerCaptures: newPlayerCaptures,\r\n    currentPlayer: (currentPlayer + 1) % 2,\r\n  };\r\n\r\n  logGameState(`Player ${currentPlayer + 1} captured with a ${selectedCard.rank}`, newState);\r\n  return newState;\r\n};\r\n\r\n/**\r\n * Calculates the scores for each player.\r\n * @param {Array} playerCaptures - An array of captured cards for each player.\r\n * @returns {Array} An array of scores for each player.\r\n */\r\nexport const calculateScores = (playerCaptures) => {\r\n  const scores = [0, 0];\r\n\r\n  // Flatten the captured groups for each player to get a simple list of cards for scoring\r\n  const flatPlayerCaptures = playerCaptures.map(captureGroups => captureGroups.flat());\r\n\r\n  flatPlayerCaptures.forEach((captures, playerIndex) => {\r\n    let score = 0;\r\n    for (const card of captures) {\r\n      if (card.rank === 'A') {\r\n        score += 1;\r\n      } else if (card.rank === '10' && card.suit === '♦') {\r\n        score += 2;\r\n      } else if (card.rank === '2' && card.suit === '♠') {\r\n        score += 1;\r\n      }\r\n    }\r\n    scores[playerIndex] = score;\r\n  });\r\n\r\n  // Add bonus points for the player with the most cards\r\n  if (flatPlayerCaptures[0].length > flatPlayerCaptures[1].length) {\r\n    scores[0] += 3;\r\n  } else if (flatPlayerCaptures[1].length > flatPlayerCaptures[0].length) {\r\n    scores[1] += 3;\r\n  }\r\n\r\n  return scores;\r\n};\r\n\r\n/**\r\n * Checks if the round is over.\r\n * @param {object} gameState - The current game state.\r\n * @returns {boolean} True if the round is over, false otherwise.\r\n */\r\nexport const isRoundOver = (gameState) => {\r\n  return gameState.playerHands.every((hand) => hand.length === 0);\r\n};\r\n\r\n/**\r\n * Checks if the game is over.\r\n * @param {object} gameState - The current game state.\r\n * @returns {boolean} True if the game is over, false otherwise.\r\n */\r\nexport const isGameOver = (gameState) => {\r\n  return gameState.round === 2 && isRoundOver(gameState);\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}