{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\LB\\\\Desktop\\\\Linda Baloyi\\\\casino\\\\src\\\\src\\\\components\\\\GameBoard.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport PlayerHand from './PlayerHand';\nimport TableCards from './TableCards';\nimport { initializeGame, handleDrop, handleBuild, handleCapture, isRoundOver, isGameOver, calculateScores, findValidCaptures, findValidBuilds } from './game-logic';\nimport CapturedCards from './CapturedCards';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction GameBoard({\n  onRestart\n}) {\n  _s();\n  const [gameState, setGameState] = useState(initializeGame());\n  const [selectedCard, setSelectedCard] = React.useState(null);\n  const [possibleCaptures, setPossibleCaptures] = React.useState([]);\n  const [possibleBuilds, setPossibleBuilds] = React.useState([]);\n  const [actionChoice, setActionChoice] = React.useState(null);\n  const resetActionState = () => {\n    setSelectedCard(null);\n    setPossibleCaptures([]);\n    setPossibleBuilds([]);\n    setActionChoice(null);\n  };\n  const handleCardPlay = (card, player) => {\n    if (player !== gameState.currentPlayer) {\n      console.log(\"It's not your turn!\");\n      return;\n    }\n    setSelectedCard(card);\n    const captures = findValidCaptures(card, gameState.tableCards);\n    const builds = findValidBuilds(card, gameState.tableCards);\n    setPossibleCaptures(captures);\n    setPossibleBuilds(builds);\n    if (captures.length === 0 && builds.length === 0) {\n      // No capture or build possible, default to drop\n      const newGameState = handleDrop(gameState, card);\n      setGameState(newGameState);\n      resetActionState();\n    }\n  };\n  const handleSelectCard = card => {\n    if (gameState.currentPlayer !== null) {\n      setSelectedCard(card);\n      const captures = findValidCaptures(card, gameState.tableCards);\n      const builds = findValidBuilds(card, gameState.tableCards);\n      setPossibleCaptures(captures);\n      setPossibleBuilds(builds);\n    }\n  };\n  const handleAction = action => {\n    if (!selectedCard) return;\n    let newGameState = {\n      ...gameState\n    };\n    if (action === 'capture' && possibleCaptures.length > 0) {\n      // For simplicity, take the first valid capture\n      newGameState = handleCapture(gameState, selectedCard, possibleCaptures[0]);\n    } else if (action === 'build' && possibleBuilds.length > 0) {\n      // For simplicity, take the first valid build\n      newGameState = handleBuild(gameState, selectedCard, possibleBuilds[0]);\n    } else if (action === 'drop') {\n      newGameState = handleDrop(gameState, selectedCard);\n    } else if (action === 'captureLoose') {\n      // Capture loose card matching selected card rank\n      const looseMatchingCards = gameState.tableCards.filter(c => c.type !== 'build' && c.rank === selectedCard.rank);\n      if (looseMatchingCards.length > 0) {\n        // Capture the first loose matching card\n        newGameState = handleCapture(gameState, selectedCard, [looseMatchingCards[0]]);\n      }\n    } else if (action === 'buildCombined') {\n      // Build combined value by merging player's card and loose card (no existing base)\n      const looseMatchingCards = gameState.tableCards.filter(c => c.type !== 'build' && c.rank === selectedCard.rank);\n      if (looseMatchingCards.length > 0) {\n        // Create a new build with selectedCard and the first loose matching card\n        newGameState = handleBuild(gameState, selectedCard, [looseMatchingCards[0]]);\n      }\n    } else if (action === 'buildNewBase') {\n      // Build new build using loose card as base\n      const looseMatchingCards = gameState.tableCards.filter(c => c.type !== 'build' && c.rank === selectedCard.rank);\n      if (looseMatchingCards.length > 0) {\n        // Create a new build with loose card as base and selectedCard as part of build cards\n        // For this, swap the order: loose card is base, selectedCard is added\n        const looseCard = looseMatchingCards[0];\n        // We create a build with both cards\n        newGameState = handleBuild(gameState, looseCard, [selectedCard]);\n      }\n    }\n    setGameState(newGameState);\n    resetActionState();\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-board\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"status-section\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Round: \", gameState.round]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 108,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 107,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"captured-cards-section\",\n      style: {\n        display: 'flex',\n        flexDirection: 'row',\n        justifyContent: 'center',\n        gap: '20px'\n      },\n      children: gameState.playerCaptures.map((capturedCards, index) => /*#__PURE__*/_jsxDEV(CapturedCards, {\n        player: index,\n        cards: capturedCards\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 112,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 110,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"table-cards-section\",\n      children: /*#__PURE__*/_jsxDEV(TableCards, {\n        cards: gameState.tableCards,\n        onDropCard: handleCardPlay\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 116,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 115,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"player-hands-section\",\n      style: {\n        display: 'flex',\n        flexDirection: 'row',\n        justifyContent: 'center',\n        gap: '10px',\n        overflowX: 'auto'\n      },\n      children: gameState.playerHands.map((hand, index) => ({\n        hand,\n        index\n      })).filter(({\n        index\n      }) => gameState.currentPlayer === index).map(({\n        hand,\n        index\n      }) => /*#__PURE__*/_jsxDEV(PlayerHand, {\n        player: index,\n        cards: hand,\n        isCurrent: true,\n        onSelectCard: handleSelectCard,\n        selectedCard: selectedCard\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 126,\n        columnNumber: 13\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 121,\n      columnNumber: 7\n    }, this), selectedCard && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"action-buttons\",\n      children: [possibleCaptures.length > 0 && /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => handleAction('capture'),\n        children: \"Capture\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 140,\n        columnNumber: 13\n      }, this), possibleBuilds.length > 0 && (() => {\n        const playerHand = gameState.playerHands[gameState.currentPlayer];\n        const rankToBuild = selectedCard.rank;\n        const requiredCount = selectedCard.value;\n        const countInHand = playerHand.filter(c => c.rank === rankToBuild).length;\n        const canBuild = countInHand >= requiredCount;\n        return /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => canBuild && handleAction('build'),\n          disabled: !canBuild,\n          title: !canBuild ? 'Not enough copies of this card in hand to build' : '',\n          children: \"Build\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 151,\n          columnNumber: 15\n        }, this);\n      })(), (() => {\n        const cardRank = selectedCard.rank;\n        const buildWithSameRank = gameState.tableCards.some(c => {\n          if (c.type === 'build') {\n            return c.cards.some(buildCard => buildCard.rank === cardRank);\n          }\n          return false;\n        });\n        const looseCardWithSameRank = gameState.tableCards.some(c => c.type !== 'build' && c.rank === cardRank);\n        const canDrop = !(buildWithSameRank || looseCardWithSameRank);\n        return /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => canDrop && handleAction('drop'),\n          disabled: !canDrop,\n          title: !canDrop ? 'Card rank already represented in an active build or on the table' : '',\n          children: \"Drop\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 173,\n          columnNumber: 15\n        }, this);\n      })(), (() => {\n        const cardRank = selectedCard.rank;\n        const looseMatchingCards = gameState.tableCards.filter(c => c.type !== 'build' && c.rank === cardRank);\n        if (looseMatchingCards.length === 0) {\n          return null;\n        }\n        const playerHand = gameState.playerHands[gameState.currentPlayer];\n        const countInHand = playerHand.filter(c => c.rank === cardRank).length;\n\n        // Validation for capture option: player must have at least one selectedCard and loose card exists\n        const canCapture = countInHand > 0;\n\n        // Validation for build combined value (merge player's card and loose card) - no existing base\n        // For simplicity, assume can build combined if no existing build with this rank on table\n        const hasBuildWithRank = gameState.tableCards.some(c => c.type === 'build' && c.cards.some(bc => bc.rank === cardRank));\n        const canBuildCombined = !hasBuildWithRank && countInHand >= 2; // Need at least 2 copies to merge\n\n        // Validation for build new build using loose card as base\n        // For simplicity, allow if no existing build with this rank and player has at least 1 copy\n        const canBuildNewBase = !hasBuildWithRank && countInHand >= 1;\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"context-options\",\n          style: {\n            marginTop: '10px'\n          },\n          children: [/*#__PURE__*/_jsxDEV(\"p\", {\n            children: \"Options for matching loose card(s) on table:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 209,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => handleAction('captureLoose'),\n            disabled: !canCapture,\n            title: !canCapture ? 'Not enough copies of this card in hand to capture' : 'Capture the loose card',\n            style: {\n              marginRight: '5px'\n            },\n            children: \"Capture Loose Card\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 210,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => handleAction('buildCombined'),\n            disabled: !canBuildCombined,\n            title: !canBuildCombined ? 'Cannot build combined value: conflicting builds or insufficient cards' : 'Build combined value by merging your card and loose card',\n            style: {\n              marginRight: '5px'\n            },\n            children: \"Build Combined Value\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 218,\n            columnNumber: 17\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => handleAction('buildNewBase'),\n            disabled: !canBuildNewBase,\n            title: !canBuildNewBase ? 'Cannot build new base: conflicting builds or insufficient cards' : 'Build new build using loose card as base',\n            children: \"Build New Base\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 226,\n            columnNumber: 17\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 208,\n          columnNumber: 15\n        }, this);\n      })()]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 137,\n      columnNumber: 9\n    }, this), gameState.gameOver && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game-over-section\",\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Game Over\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 240,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: [\"Winner: Player \", gameState.winner + 1]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 241,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: onRestart,\n        children: \"Play Again\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 242,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 239,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 106,\n    columnNumber: 5\n  }, this);\n}\n_s(GameBoard, \"JT0xqhOVwpXkSpolnvpLpY1f3aw=\");\n_c = GameBoard;\nexport default GameBoard;\nvar _c;\n$RefreshReg$(_c, \"GameBoard\");","map":{"version":3,"names":["React","useState","PlayerHand","TableCards","initializeGame","handleDrop","handleBuild","handleCapture","isRoundOver","isGameOver","calculateScores","findValidCaptures","findValidBuilds","CapturedCards","jsxDEV","_jsxDEV","GameBoard","onRestart","_s","gameState","setGameState","selectedCard","setSelectedCard","possibleCaptures","setPossibleCaptures","possibleBuilds","setPossibleBuilds","actionChoice","setActionChoice","resetActionState","handleCardPlay","card","player","currentPlayer","console","log","captures","tableCards","builds","length","newGameState","handleSelectCard","handleAction","action","looseMatchingCards","filter","c","type","rank","looseCard","className","children","round","fileName","_jsxFileName","lineNumber","columnNumber","style","display","flexDirection","justifyContent","gap","playerCaptures","map","capturedCards","index","cards","onDropCard","overflowX","playerHands","hand","isCurrent","onSelectCard","onClick","playerHand","rankToBuild","requiredCount","value","countInHand","canBuild","disabled","title","cardRank","buildWithSameRank","some","buildCard","looseCardWithSameRank","canDrop","canCapture","hasBuildWithRank","bc","canBuildCombined","canBuildNewBase","marginTop","marginRight","gameOver","winner","_c","$RefreshReg$"],"sources":["C:/Users/LB/Desktop/Linda Baloyi/casino/src/src/components/GameBoard.js"],"sourcesContent":["import React, { useState } from 'react';\nimport PlayerHand from './PlayerHand';\nimport TableCards from './TableCards';\n\nimport {\n  initializeGame,\n  handleDrop,\n  handleBuild,\n  handleCapture,\n  isRoundOver,\n  isGameOver,\n  calculateScores,\n  findValidCaptures,\n  findValidBuilds,\n} from './game-logic';\nimport CapturedCards from './CapturedCards';\n\nfunction GameBoard({ onRestart }) {\n  const [gameState, setGameState] = useState(initializeGame());\n  const [selectedCard, setSelectedCard] = React.useState(null);\n  const [possibleCaptures, setPossibleCaptures] = React.useState([]);\n  const [possibleBuilds, setPossibleBuilds] = React.useState([]);\n  const [actionChoice, setActionChoice] = React.useState(null);\n\n  const resetActionState = () => {\n    setSelectedCard(null);\n    setPossibleCaptures([]);\n    setPossibleBuilds([]);\n    setActionChoice(null);\n  };\n\n  const handleCardPlay = (card, player) => {\n    if (player !== gameState.currentPlayer) {\n      console.log(\"It's not your turn!\");\n      return;\n    }\n\n    setSelectedCard(card);\n    const captures = findValidCaptures(card, gameState.tableCards);\n    const builds = findValidBuilds(card, gameState.tableCards);\n    setPossibleCaptures(captures);\n    setPossibleBuilds(builds);\n\n    if (captures.length === 0 && builds.length === 0) {\n      // No capture or build possible, default to drop\n      const newGameState = handleDrop(gameState, card);\n      setGameState(newGameState);\n      resetActionState();\n    }\n  };\n\n  const handleSelectCard = (card) => {\n    if (gameState.currentPlayer !== null) {\n      setSelectedCard(card);\n      const captures = findValidCaptures(card, gameState.tableCards);\n      const builds = findValidBuilds(card, gameState.tableCards);\n      setPossibleCaptures(captures);\n      setPossibleBuilds(builds);\n    }\n  };\n\n  const handleAction = (action) => {\n    if (!selectedCard) return;\n\n    let newGameState = { ...gameState };\n\n    if (action === 'capture' && possibleCaptures.length > 0) {\n      // For simplicity, take the first valid capture\n      newGameState = handleCapture(gameState, selectedCard, possibleCaptures[0]);\n    } else if (action === 'build' && possibleBuilds.length > 0) {\n      // For simplicity, take the first valid build\n      newGameState = handleBuild(gameState, selectedCard, possibleBuilds[0]);\n    } else if (action === 'drop') {\n      newGameState = handleDrop(gameState, selectedCard);\n    } else if (action === 'captureLoose') {\n      // Capture loose card matching selected card rank\n      const looseMatchingCards = gameState.tableCards.filter((c) => c.type !== 'build' && c.rank === selectedCard.rank);\n      if (looseMatchingCards.length > 0) {\n        // Capture the first loose matching card\n        newGameState = handleCapture(gameState, selectedCard, [looseMatchingCards[0]]);\n      }\n    } else if (action === 'buildCombined') {\n      // Build combined value by merging player's card and loose card (no existing base)\n      const looseMatchingCards = gameState.tableCards.filter((c) => c.type !== 'build' && c.rank === selectedCard.rank);\n      if (looseMatchingCards.length > 0) {\n        // Create a new build with selectedCard and the first loose matching card\n        newGameState = handleBuild(gameState, selectedCard, [looseMatchingCards[0]]);\n      }\n    } else if (action === 'buildNewBase') {\n      // Build new build using loose card as base\n      const looseMatchingCards = gameState.tableCards.filter((c) => c.type !== 'build' && c.rank === selectedCard.rank);\n      if (looseMatchingCards.length > 0) {\n        // Create a new build with loose card as base and selectedCard as part of build cards\n        // For this, swap the order: loose card is base, selectedCard is added\n        const looseCard = looseMatchingCards[0];\n        // We create a build with both cards\n        newGameState = handleBuild(gameState, looseCard, [selectedCard]);\n      }\n    }\n\n    setGameState(newGameState);\n    resetActionState();\n  };\n\n  return (\n    <div className=\"game-board\">\n      <div className=\"status-section\">\n        <p>Round: {gameState.round}</p>\n      </div>\n      <div className=\"captured-cards-section\" style={{ display: 'flex', flexDirection: 'row', justifyContent: 'center', gap: '20px' }}>\n        {gameState.playerCaptures.map((capturedCards, index) => (\n          <CapturedCards key={index} player={index} cards={capturedCards} />\n        ))}\n      </div>\n      <div className=\"table-cards-section\">\n        <TableCards\n          cards={gameState.tableCards}\n          onDropCard={handleCardPlay}\n        />\n      </div>\n      <div className=\"player-hands-section\" style={{ display: 'flex', flexDirection: 'row', justifyContent: 'center', gap: '10px', overflowX: 'auto' }}>\n        {gameState.playerHands\n          .map((hand, index) => ({ hand, index }))\n          .filter(({ index }) => gameState.currentPlayer === index)\n          .map(({ hand, index }) => (\n            <PlayerHand\n              key={index}\n              player={index}\n              cards={hand}\n              isCurrent={true}\n              onSelectCard={handleSelectCard}\n              selectedCard={selectedCard}\n            />\n          ))}\n      </div>\n      {selectedCard && (\n        <div className=\"action-buttons\">\n          {/* Existing Capture Button */}\n          {possibleCaptures.length > 0 && (\n            <button onClick={() => handleAction('capture')}>Capture</button>\n          )}\n\n          {/* Existing Build Button */}\n          {possibleBuilds.length > 0 && (() => {\n            const playerHand = gameState.playerHands[gameState.currentPlayer];\n            const rankToBuild = selectedCard.rank;\n            const requiredCount = selectedCard.value;\n            const countInHand = playerHand.filter((c) => c.rank === rankToBuild).length;\n            const canBuild = countInHand >= requiredCount;\n            return (\n              <button\n                onClick={() => canBuild && handleAction('build')}\n                disabled={!canBuild}\n                title={!canBuild ? 'Not enough copies of this card in hand to build' : ''}\n              >\n                Build\n              </button>\n            );\n          })()}\n\n          {/* Existing Drop Button */}\n          {(() => {\n            const cardRank = selectedCard.rank;\n            const buildWithSameRank = gameState.tableCards.some((c) => {\n              if (c.type === 'build') {\n                return c.cards.some((buildCard) => buildCard.rank === cardRank);\n              }\n              return false;\n            });\n            const looseCardWithSameRank = gameState.tableCards.some((c) => c.type !== 'build' && c.rank === cardRank);\n            const canDrop = !(buildWithSameRank || looseCardWithSameRank);\n            return (\n              <button\n                onClick={() => canDrop && handleAction('drop')}\n                disabled={!canDrop}\n                title={!canDrop ? 'Card rank already represented in an active build or on the table' : ''}\n              >\n                Drop\n              </button>\n            );\n          })()}\n\n          {/* New logic: Detect loose cards on table matching selected card rank */}\n          {(() => {\n            const cardRank = selectedCard.rank;\n            const looseMatchingCards = gameState.tableCards.filter((c) => c.type !== 'build' && c.rank === cardRank);\n\n            if (looseMatchingCards.length === 0) {\n              return null;\n            }\n\n            const playerHand = gameState.playerHands[gameState.currentPlayer];\n            const countInHand = playerHand.filter((c) => c.rank === cardRank).length;\n\n            // Validation for capture option: player must have at least one selectedCard and loose card exists\n            const canCapture = countInHand > 0;\n\n            // Validation for build combined value (merge player's card and loose card) - no existing base\n            // For simplicity, assume can build combined if no existing build with this rank on table\n            const hasBuildWithRank = gameState.tableCards.some((c) => c.type === 'build' && c.cards.some((bc) => bc.rank === cardRank));\n            const canBuildCombined = !hasBuildWithRank && countInHand >= 2; // Need at least 2 copies to merge\n\n            // Validation for build new build using loose card as base\n            // For simplicity, allow if no existing build with this rank and player has at least 1 copy\n            const canBuildNewBase = !hasBuildWithRank && countInHand >= 1;\n\n            return (\n              <div className=\"context-options\" style={{ marginTop: '10px' }}>\n                <p>Options for matching loose card(s) on table:</p>\n                <button\n                  onClick={() => handleAction('captureLoose')}\n                  disabled={!canCapture}\n                  title={!canCapture ? 'Not enough copies of this card in hand to capture' : 'Capture the loose card'}\n                  style={{ marginRight: '5px' }}\n                >\n                  Capture Loose Card\n                </button>\n                <button\n                  onClick={() => handleAction('buildCombined')}\n                  disabled={!canBuildCombined}\n                  title={!canBuildCombined ? 'Cannot build combined value: conflicting builds or insufficient cards' : 'Build combined value by merging your card and loose card'}\n                  style={{ marginRight: '5px' }}\n                >\n                  Build Combined Value\n                </button>\n                <button\n                  onClick={() => handleAction('buildNewBase')}\n                  disabled={!canBuildNewBase}\n                  title={!canBuildNewBase ? 'Cannot build new base: conflicting builds or insufficient cards' : 'Build new build using loose card as base'}\n                >\n                  Build New Base\n                </button>\n              </div>\n            );\n          })()}\n        </div>\n      )}\n      {gameState.gameOver && (\n        <div className=\"game-over-section\">\n          <h2>Game Over</h2>\n          <p>Winner: Player {gameState.winner + 1}</p>\n          <button onClick={onRestart}>Play Again</button>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default GameBoard;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}