{"ast":null,"code":"// src/components/game-logic.js\n\n/**\n * Initializes the game state, including shuffling the deck and dealing cards.\n * @returns {object} The initial game state.\n */\nexport const initializeGame = () => {\n  const suits = ['♠', '♥', '♦', '♣'];\n  const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];\n  let deck = [];\n  for (const suit of suits) {\n    for (const rank of ranks) {\n      deck.push({\n        suit,\n        rank,\n        value: rankValue(rank)\n      });\n    }\n  }\n  deck = shuffleDeck(deck);\n  const playerHands = [[], []];\n  for (let i = 0; i < 10; i++) {\n    playerHands[0].push(deck.pop());\n    playerHands[1].push(deck.pop());\n  }\n  return {\n    deck,\n    playerHands,\n    tableCards: [],\n    playerCaptures: [[], []],\n    currentPlayer: 0,\n    round: 1,\n    scores: [0, 0],\n    gameOver: false,\n    winner: null\n  };\n};\n\n/**\n * Shuffles the deck of cards.\n * @param {Array} deck - The deck to shuffle.\n * @returns {Array} The shuffled deck.\n */\nexport const shuffleDeck = deck => {\n  for (let i = deck.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [deck[i], deck[j]] = [deck[j], deck[i]];\n  }\n  return deck;\n};\n\n/**\n * Converts a card's rank to its numeric value.\n * @param {string} rank - The rank of the card (e.g., 'A', '5', 'K').\n * @returns {number} The numeric value of the rank.\n */\nexport const rankValue = rank => {\n  if (rank === 'A') return 1;\n  if (rank === 'J') return 11;\n  if (rank === 'Q') return 12;\n  if (rank === 'K') return 13;\n  return parseInt(rank, 10);\n};\n\n/**\n * Handles dropping a card on the table.\n * @param {object} gameState - The current game state.\n * @param {object} card - The card to drop.\n * @returns {object} The new game state.\n */\nexport const handleDrop = (gameState, card) => {\n  const {\n    playerHands,\n    tableCards,\n    currentPlayer\n  } = gameState;\n\n  // Check if the card's rank is already represented in an active build or on the table\n  const cardRank = card.rank;\n\n  // Check builds on the table\n  const buildWithSameRank = tableCards.some(c => {\n    if (c.type === 'build') {\n      return c.cards.some(buildCard => buildCard.rank === cardRank);\n    }\n    return false;\n  });\n\n  // Check loose cards on the table\n  const looseCardWithSameRank = tableCards.some(c => c.type !== 'build' && c.rank === cardRank);\n  if (buildWithSameRank || looseCardWithSameRank) {\n    // Prevent dropping the card if rank already represented\n    return gameState;\n  }\n\n  // Remove the card from the player's hand\n  const newPlayerHands = [...playerHands];\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === card.rank && c.suit === card.suit);\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  } else {\n    console.error(\"Card to drop not found in player's hand.\");\n    return gameState; // Card not found, abort.\n  }\n  // Add the card to the table\n  const newTableCards = [...tableCards, card];\n  return {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    currentPlayer: (currentPlayer + 1) % 2\n  };\n};\n\n/**\n * Handles creating a build.\n * @param {object} gameState - The current game state.\n * @param {object} playerCard - The card played from the hand.\n * @param {Array} tableCardsInBuild - The cards from the table to include in the build.\n * @param {number} buildValue - The target value of the build.\n * @returns {object} The new game state.\n */\nexport const handleBuild = (gameState, playerCard, tableCardsInBuild, buildValue) => {\n  const {\n    playerHands,\n    tableCards,\n    currentPlayer\n  } = gameState;\n  const playerHand = playerHands[currentPlayer];\n\n  // Validation 1: Player must have a card in hand that can capture this new build.\n  // The card used for the build doesn't count.\n  const canCaptureBuild = playerHand.some(c => rankValue(c.rank) === buildValue && c !== playerCard);\n  if (!canCaptureBuild) {\n    console.error(`Cannot build ${buildValue}. Player does not have a card of this value to capture it later.`);\n    // In a real UI, you'd show a message instead of logging.\n    return gameState; // Invalid build, return original state.\n  }\n  const allCardsInBuild = [playerCard, ...tableCardsInBuild];\n  const sumOfCards = allCardsInBuild.reduce((sum, card) => sum + rankValue(card.rank), 0);\n\n  // Validation 2: The sum of cards in the build must equal the declared build value.\n  if (sumOfCards !== buildValue) {\n    console.error(`Sum of cards (${sumOfCards}) does not match build value (${buildValue}).`);\n    return gameState;\n  }\n\n  // Create the new build object\n  const newBuild = {\n    type: 'build',\n    cards: allCardsInBuild,\n    value: buildValue,\n    owner: currentPlayer\n  };\n\n  // Remove the played card from the player's hand\n  const newPlayerHands = [...playerHands];\n  const cardIndex = newPlayerHands[currentPlayer].findIndex(c => c.rank === playerCard.rank && c.suit === playerCard.suit);\n  if (cardIndex > -1) {\n    newPlayerHands[currentPlayer].splice(cardIndex, 1);\n  } else {\n    console.error(\"Played card not found in hand.\");\n    return gameState;\n  }\n\n  // Remove the used cards from the table\n  const tableCardIdentifiers = tableCardsInBuild.map(c => `${c.rank}-${c.suit}`);\n  const newTableCards = tableCards.filter(c => !tableCardIdentifiers.includes(`${c.rank}-${c.suit}`));\n  newTableCards.push(newBuild);\n  return {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    currentPlayer: (currentPlayer + 1) % 2\n  };\n};\n\n/**\n * Finds all valid captures for a given card.\n * @param {object} selectedCard - The card selected from the player's hand.\n * @param {Array} tableCards - The cards on the table.\n * @returns {Array} An array of valid captures.\n */\nexport const findValidCaptures = (selectedCard, tableCards) => {\n  const validCaptures = [];\n  const cardValue = selectedCard.value;\n\n  // Helper function to find combinations\n  const findCombinations = (cards, target) => {\n    const result = [];\n    const find = (startIndex, currentCombination, currentSum) => {\n      if (currentSum === target) {\n        result.push(currentCombination);\n        return;\n      }\n      if (currentSum > target) {\n        return;\n      }\n      for (let i = startIndex; i < cards.length; i++) {\n        find(i + 1, [...currentCombination, cards[i]], currentSum + cards[i].value);\n      }\n    };\n    find(0, [], 0);\n    return result;\n  };\n\n  // 1. Find all combinations of loose cards that sum up to the card value\n  const looseCards = tableCards.filter(c => c.type !== 'build');\n  const looseCardCombinations = findCombinations(looseCards, cardValue);\n  for (const combination of looseCardCombinations) {\n    validCaptures.push(combination);\n  }\n\n  // 2. Find all builds that can be captured\n  const buildCaptures = tableCards.filter(c => c.type === 'build' && c.value === cardValue);\n  for (const build of buildCaptures) {\n    validCaptures.push([build]);\n  }\n  return validCaptures;\n};\n\n/**\n * Finds all valid builds for a given card.\n * @param {object} selectedCard - The card selected from the player's hand.\n * @param {Array} tableCards - The cards on the table.\n * @returns {Array} An array of valid builds.\n */\nexport const findValidBuilds = (selectedCard, tableCards) => {\n  const validBuilds = [];\n  const cardValue = selectedCard.value;\n\n  // Helper function to find combinations\n  const findCombinations = (cards, target) => {\n    const result = [];\n    const find = (startIndex, currentCombination, currentSum) => {\n      if (currentSum === target) {\n        result.push(currentCombination);\n        return;\n      }\n      if (currentSum > target) {\n        return;\n      }\n      for (let i = startIndex; i < cards.length; i++) {\n        find(i + 1, [...currentCombination, cards[i]], currentSum + cards[i].value);\n      }\n    };\n    find(0, [], 0);\n    return result;\n  };\n\n  // Find all combinations of loose cards that sum up to the cardValue\n  const looseCards = tableCards.filter(c => c.type !== 'build');\n  const looseCardCombinations = findCombinations(looseCards, cardValue);\n  for (const combination of looseCardCombinations) {\n    validBuilds.push(combination);\n  }\n  return validBuilds;\n};\n\n/**\n * Handles capturing cards from the table.\n * @param {object} gameState - The current game state.\n * @param {object} selectedCard - The card selected from the player's hand.\n * @param {Array} selectedTableCards - The cards selected from the table to capture.\n * @returns {object} The new game state.\n */\nexport const handleCapture = (gameState, selectedCard, selectedTableCards) => {\n  const {\n    playerHands,\n    tableCards,\n    playerCaptures,\n    currentPlayer\n  } = gameState;\n  const capturedCards = [selectedCard, ...selectedTableCards];\n\n  // Remove the selected card from the player's hand\n  const newPlayerHands = [...playerHands];\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === selectedCard.rank && c.suit === selectedCard.suit);\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  } else {\n    console.error(\"Card to capture not found in player's hand.\");\n    return gameState; // Card not found, abort.\n  }\n  // Remove the captured cards from the table\n  const newTableCards = tableCards.filter(c => !selectedTableCards.includes(c));\n\n  // Add the captured cards to the player's captures\n  const newPlayerCaptures = [...playerCaptures];\n  newPlayerCaptures[currentPlayer] = [...newPlayerCaptures[currentPlayer], ...capturedCards];\n  return {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    playerCaptures: newPlayerCaptures,\n    currentPlayer: (currentPlayer + 1) % 2\n  };\n};\n\n/**\n * Calculates the scores for each player.\n * @param {Array} playerCaptures - An array of captured cards for each player.\n * @returns {Array} An array of scores for each player.\n */\nexport const calculateScores = playerCaptures => {\n  const scores = [0, 0];\n  playerCaptures.forEach((captures, playerIndex) => {\n    let score = 0;\n    for (const card of captures) {\n      if (card.rank === 'A') {\n        score += 1;\n      } else if (card.rank === '10' && card.suit === '♦') {\n        score += 2;\n      } else if (card.rank === '2' && card.suit === '♠') {\n        score += 1;\n      }\n    }\n    scores[playerIndex] = score;\n  });\n\n  // Add bonus points for the player with the most cards\n  if (playerCaptures[0].length > playerCaptures[1].length) {\n    scores[0] += 3;\n  } else if (playerCaptures[1].length > playerCaptures[0].length) {\n    scores[1] += 3;\n  }\n  return scores;\n};\n\n/**\n * Checks if the round is over.\n * @param {object} gameState - The current game state.\n * @returns {boolean} True if the round is over, false otherwise.\n */\nexport const isRoundOver = gameState => {\n  return gameState.playerHands.every(hand => hand.length === 0);\n};\n\n/**\n * Checks if the game is over.\n * @param {object} gameState - The current game state.\n * @returns {boolean} True if the game is over, false otherwise.\n */\nexport const isGameOver = gameState => {\n  return gameState.round === 2 && isRoundOver(gameState);\n};","map":{"version":3,"names":["initializeGame","suits","ranks","deck","suit","rank","push","value","rankValue","shuffleDeck","playerHands","i","pop","tableCards","playerCaptures","currentPlayer","round","scores","gameOver","winner","length","j","Math","floor","random","parseInt","handleDrop","gameState","card","cardRank","buildWithSameRank","some","c","type","cards","buildCard","looseCardWithSameRank","newPlayerHands","hand","cardIndex","findIndex","splice","console","error","newTableCards","handleBuild","playerCard","tableCardsInBuild","buildValue","playerHand","canCaptureBuild","allCardsInBuild","sumOfCards","reduce","sum","newBuild","owner","tableCardIdentifiers","map","filter","includes","findValidCaptures","selectedCard","validCaptures","cardValue","findCombinations","target","result","find","startIndex","currentCombination","currentSum","looseCards","looseCardCombinations","combination","buildCaptures","build","findValidBuilds","validBuilds","handleCapture","selectedTableCards","capturedCards","newPlayerCaptures","calculateScores","forEach","captures","playerIndex","score","isRoundOver","every","isGameOver"],"sources":["C:/Users/LB/Desktop/Linda Baloyi/casino/src/src/components/game-logic.js"],"sourcesContent":["\n// src/components/game-logic.js\n\n/**\n * Initializes the game state, including shuffling the deck and dealing cards.\n * @returns {object} The initial game state.\n */\nexport const initializeGame = () => {\n  const suits = ['♠', '♥', '♦', '♣'];\n  const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];\n  let deck = [];\n\n  for (const suit of suits) {\n    for (const rank of ranks) {\n      deck.push({ suit, rank, value: rankValue(rank) });\n    }\n  }\n\n  deck = shuffleDeck(deck);\n\n  const playerHands = [[], []];\n  for (let i = 0; i < 10; i++) {\n    playerHands[0].push(deck.pop());\n    playerHands[1].push(deck.pop());\n  }\n\n  return {\n    deck,\n    playerHands,\n    tableCards: [],\n    playerCaptures: [[], []],\n    currentPlayer: 0,\n    round: 1,\n    scores: [0, 0],\n    gameOver: false,\n    winner: null,\n  };\n};\n\n/**\n * Shuffles the deck of cards.\n * @param {Array} deck - The deck to shuffle.\n * @returns {Array} The shuffled deck.\n */\nexport const shuffleDeck = (deck) => {\n  for (let i = deck.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [deck[i], deck[j]] = [deck[j], deck[i]];\n  }\n  return deck;\n};\n\n/**\n * Converts a card's rank to its numeric value.\n * @param {string} rank - The rank of the card (e.g., 'A', '5', 'K').\n * @returns {number} The numeric value of the rank.\n */\nexport const rankValue = (rank) => {\n  if (rank === 'A') return 1;\n  if (rank === 'J') return 11;\n  if (rank === 'Q') return 12;\n  if (rank === 'K') return 13;\n  return parseInt(rank, 10);\n};\n\n/**\n * Handles dropping a card on the table.\n * @param {object} gameState - The current game state.\n * @param {object} card - The card to drop.\n * @returns {object} The new game state.\n */\nexport const handleDrop = (gameState, card) => {\n  const { playerHands, tableCards, currentPlayer } = gameState;\n\n  // Check if the card's rank is already represented in an active build or on the table\n  const cardRank = card.rank;\n\n  // Check builds on the table\n  const buildWithSameRank = tableCards.some((c) => {\n    if (c.type === 'build') {\n      return c.cards.some((buildCard) => buildCard.rank === cardRank);\n    }\n    return false;\n  });\n\n  // Check loose cards on the table\n  const looseCardWithSameRank = tableCards.some((c) => c.type !== 'build' && c.rank === cardRank);\n\n  if (buildWithSameRank || looseCardWithSameRank) {\n    // Prevent dropping the card if rank already represented\n    return gameState;\n  }\n\n  // Remove the card from the player's hand\n  const newPlayerHands = [...playerHands];\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === card.rank && c.suit === card.suit);\n\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  } else {\n    console.error(\"Card to drop not found in player's hand.\");\n    return gameState; // Card not found, abort.\n  }\n  // Add the card to the table\n  const newTableCards = [...tableCards, card];\n\n  return {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    currentPlayer: (currentPlayer + 1) % 2,\n  };\n};\n\n/**\n * Handles creating a build.\n * @param {object} gameState - The current game state.\n * @param {object} playerCard - The card played from the hand.\n * @param {Array} tableCardsInBuild - The cards from the table to include in the build.\n * @param {number} buildValue - The target value of the build.\n * @returns {object} The new game state.\n */\nexport const handleBuild = (gameState, playerCard, tableCardsInBuild, buildValue) => {\n  const { playerHands, tableCards, currentPlayer } = gameState;\n  const playerHand = playerHands[currentPlayer];\n\n  // Validation 1: Player must have a card in hand that can capture this new build.\n  // The card used for the build doesn't count.\n  const canCaptureBuild = playerHand.some(c => rankValue(c.rank) === buildValue && c !== playerCard);\n  if (!canCaptureBuild) {\n    console.error(`Cannot build ${buildValue}. Player does not have a card of this value to capture it later.`);\n    // In a real UI, you'd show a message instead of logging.\n    return gameState; // Invalid build, return original state.\n  }\n\n  const allCardsInBuild = [playerCard, ...tableCardsInBuild];\n  const sumOfCards = allCardsInBuild.reduce((sum, card) => sum + rankValue(card.rank), 0);\n\n  // Validation 2: The sum of cards in the build must equal the declared build value.\n  if (sumOfCards !== buildValue) {\n      console.error(`Sum of cards (${sumOfCards}) does not match build value (${buildValue}).`);\n      return gameState;\n  }\n\n  // Create the new build object\n  const newBuild = {\n    type: 'build',\n    cards: allCardsInBuild,\n    value: buildValue,\n    owner: currentPlayer,\n  };\n\n  // Remove the played card from the player's hand\n  const newPlayerHands = [...playerHands];\n  const cardIndex = newPlayerHands[currentPlayer].findIndex(c => c.rank === playerCard.rank && c.suit === playerCard.suit);\n  if (cardIndex > -1) {\n    newPlayerHands[currentPlayer].splice(cardIndex, 1);\n  } else {\n    console.error(\"Played card not found in hand.\");\n    return gameState;\n  }\n\n  // Remove the used cards from the table\n  const tableCardIdentifiers = tableCardsInBuild.map(c => `${c.rank}-${c.suit}`);\n  const newTableCards = tableCards.filter(c => !tableCardIdentifiers.includes(`${c.rank}-${c.suit}`));\n  newTableCards.push(newBuild);\n\n  return {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    currentPlayer: (currentPlayer + 1) % 2,\n  };\n};\n\n/**\n * Finds all valid captures for a given card.\n * @param {object} selectedCard - The card selected from the player's hand.\n * @param {Array} tableCards - The cards on the table.\n * @returns {Array} An array of valid captures.\n */\nexport const findValidCaptures = (selectedCard, tableCards) => {\n  const validCaptures = [];\n  const cardValue = selectedCard.value;\n\n  // Helper function to find combinations\n  const findCombinations = (cards, target) => {\n    const result = [];\n    const find = (startIndex, currentCombination, currentSum) => {\n      if (currentSum === target) {\n        result.push(currentCombination);\n        return;\n      }\n      if (currentSum > target) {\n        return;\n      }\n      for (let i = startIndex; i < cards.length; i++) {\n        find(i + 1, [...currentCombination, cards[i]], currentSum + cards[i].value);\n      }\n    };\n    find(0, [], 0);\n    return result;\n  };\n\n  // 1. Find all combinations of loose cards that sum up to the card value\n  const looseCards = tableCards.filter((c) => c.type !== 'build');\n  const looseCardCombinations = findCombinations(looseCards, cardValue);\n  for (const combination of looseCardCombinations) {\n    validCaptures.push(combination);\n  }\n\n  // 2. Find all builds that can be captured\n  const buildCaptures = tableCards.filter((c) => c.type === 'build' && c.value === cardValue);\n  for (const build of buildCaptures) {\n    validCaptures.push([build]);\n  }\n\n  return validCaptures;\n};\n\n/**\n * Finds all valid builds for a given card.\n * @param {object} selectedCard - The card selected from the player's hand.\n * @param {Array} tableCards - The cards on the table.\n * @returns {Array} An array of valid builds.\n */\nexport const findValidBuilds = (selectedCard, tableCards) => {\n  const validBuilds = [];\n  const cardValue = selectedCard.value;\n\n  // Helper function to find combinations\n  const findCombinations = (cards, target) => {\n    const result = [];\n    const find = (startIndex, currentCombination, currentSum) => {\n      if (currentSum === target) {\n        result.push(currentCombination);\n        return;\n      }\n      if (currentSum > target) {\n        return;\n      }\n      for (let i = startIndex; i < cards.length; i++) {\n        find(i + 1, [...currentCombination, cards[i]], currentSum + cards[i].value);\n      }\n    };\n    find(0, [], 0);\n    return result;\n  };\n\n  // Find all combinations of loose cards that sum up to the cardValue\n  const looseCards = tableCards.filter((c) => c.type !== 'build');\n  const looseCardCombinations = findCombinations(looseCards, cardValue);\n  for (const combination of looseCardCombinations) {\n    validBuilds.push(combination);\n  }\n\n  return validBuilds;\n};\n\n/**\n * Handles capturing cards from the table.\n * @param {object} gameState - The current game state.\n * @param {object} selectedCard - The card selected from the player's hand.\n * @param {Array} selectedTableCards - The cards selected from the table to capture.\n * @returns {object} The new game state.\n */\nexport const handleCapture = (gameState, selectedCard, selectedTableCards) => {\n  const { playerHands, tableCards, playerCaptures, currentPlayer } = gameState;\n\n  const capturedCards = [selectedCard, ...selectedTableCards];\n\n  // Remove the selected card from the player's hand\n  const newPlayerHands = [...playerHands];\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === selectedCard.rank && c.suit === selectedCard.suit);\n\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  } else {\n    console.error(\"Card to capture not found in player's hand.\");\n    return gameState; // Card not found, abort.\n  }\n  // Remove the captured cards from the table\n  const newTableCards = tableCards.filter((c) => !selectedTableCards.includes(c));\n\n  // Add the captured cards to the player's captures\n  const newPlayerCaptures = [...playerCaptures];\n  newPlayerCaptures[currentPlayer] = [...newPlayerCaptures[currentPlayer], ...capturedCards];\n\n  return {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    playerCaptures: newPlayerCaptures,\n    currentPlayer: (currentPlayer + 1) % 2,\n  };\n};\n\n/**\n * Calculates the scores for each player.\n * @param {Array} playerCaptures - An array of captured cards for each player.\n * @returns {Array} An array of scores for each player.\n */\nexport const calculateScores = (playerCaptures) => {\n  const scores = [0, 0];\n\n  playerCaptures.forEach((captures, playerIndex) => {\n    let score = 0;\n    for (const card of captures) {\n      if (card.rank === 'A') {\n        score += 1;\n      } else if (card.rank === '10' && card.suit === '♦') {\n        score += 2;\n      } else if (card.rank === '2' && card.suit === '♠') {\n        score += 1;\n      }\n    }\n    scores[playerIndex] = score;\n  });\n\n  // Add bonus points for the player with the most cards\n  if (playerCaptures[0].length > playerCaptures[1].length) {\n    scores[0] += 3;\n  } else if (playerCaptures[1].length > playerCaptures[0].length) {\n    scores[1] += 3;\n  }\n\n  return scores;\n};\n\n/**\n * Checks if the round is over.\n * @param {object} gameState - The current game state.\n * @returns {boolean} True if the round is over, false otherwise.\n */\nexport const isRoundOver = (gameState) => {\n  return gameState.playerHands.every((hand) => hand.length === 0);\n};\n\n/**\n * Checks if the game is over.\n * @param {object} gameState - The current game state.\n * @returns {boolean} True if the game is over, false otherwise.\n */\nexport const isGameOver = (gameState) => {\n  return gameState.round === 2 && isRoundOver(gameState);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}