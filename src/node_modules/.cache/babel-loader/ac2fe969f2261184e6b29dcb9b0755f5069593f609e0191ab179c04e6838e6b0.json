{"ast":null,"code":"// src/components/game-logic.js\n\n/**\n * Initializes the game state, including shuffling the deck and dealing cards.\n * @returns {object} The initial game state.\n */\nexport const initializeGame = () => {\n  const suits = ['♠', '♥', '♦', '♣'];\n  const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];\n  let deck = [];\n  for (const suit of suits) {\n    for (const rank of ranks) {\n      deck.push({\n        suit,\n        rank,\n        value: rankValue(rank)\n      });\n    }\n  }\n  deck = shuffleDeck(deck);\n  const playerHands = [[], []];\n  for (let i = 0; i < 10; i++) {\n    playerHands[0].push(deck.pop());\n    playerHands[1].push(deck.pop());\n  }\n  return {\n    deck,\n    playerHands,\n    tableCards: [],\n    playerCaptures: [[], []],\n    currentPlayer: 0,\n    round: 1,\n    scores: [0, 0],\n    gameOver: false,\n    winner: null\n  };\n};\n\n/**\n * Shuffles the deck of cards.\n * @param {Array} deck - The deck to shuffle.\n * @returns {Array} The shuffled deck.\n */\nexport const shuffleDeck = deck => {\n  for (let i = deck.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [deck[i], deck[j]] = [deck[j], deck[i]];\n  }\n  return deck;\n};\n\n/**\n * Converts a card's rank to its numeric value.\n * @param {string} rank - The rank of the card (e.g., 'A', '5', 'K').\n * @returns {number} The numeric value of the rank.\n */\nexport const rankValue = rank => {\n  if (rank === 'A') return 1;\n  if (rank === 'J') return 11;\n  if (rank === 'Q') return 12;\n  if (rank === 'K') return 13;\n  return parseInt(rank, 10);\n};\n\n/**\n * Logs the current state of the game for debugging purposes.\n * @param {string} moveDescription - A description of the move that just occurred.\n * @param {object} gameState - The game state to log.\n */\nconst logGameState = (moveDescription, gameState) => {\n  // Using console.group to create collapsible log groups for better readability\n  console.group(`%cMove: ${moveDescription}`, 'color: blue; font-weight: bold;');\n  console.log('Table Cards:', JSON.parse(JSON.stringify(gameState.tableCards)));\n  console.log('Player 1 Hand:', JSON.parse(JSON.stringify(gameState.playerHands[0])));\n  console.log('Player 2 Hand:', JSON.parse(JSON.stringify(gameState.playerHands[1])));\n  console.log('Player 1 Captures:', JSON.parse(JSON.stringify(gameState.playerCaptures[0])));\n  console.log('Player 2 Captures:', JSON.parse(JSON.stringify(gameState.playerCaptures[1])));\n  console.log(`Next turn: Player ${gameState.currentPlayer + 1}`);\n  console.groupEnd();\n};\n\n/**\n * Handles trailing a card to the table.\n * @param {object} gameState - The current game state.\n * @param {object} card - The card to trail.\n * @returns {object} The new game state.\n */\nexport const handleTrail = (gameState, card) => {\n  const {\n    playerHands,\n    tableCards,\n    currentPlayer,\n    round\n  } = gameState;\n\n  // New Rule: In round 1, a player cannot trail if they own a build.\n  if (round === 1) {\n    const playerOwnsBuild = tableCards.some(c => c.type === 'build' && c.owner === currentPlayer);\n    if (playerOwnsBuild) {\n      alert(\"You cannot trail a card while you own a build in the first round. You must capture or build.\");\n      return gameState; // Invalid move\n    }\n  }\n\n  // Rule: You cannot trail a card if a loose card of the same rank is on the table.\n  const looseCardRanks = tableCards.filter(c => !c.type) // Only check loose cards, not builds\n  .map(c => c.rank);\n  if (looseCardRanks.includes(card.rank)) {\n    alert(`You cannot trail a ${card.rank} because one is already on the table.`);\n    return gameState; // Invalid move, return original state.\n  }\n\n  // Remove the card from the player's hand\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === card.rank && c.suit === card.suit);\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  } else {\n    console.error(\"Card to trail not found in player's hand.\");\n    return gameState; // Card not found, abort.\n  }\n  const newState = {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: [...tableCards, card],\n    currentPlayer: (currentPlayer + 1) % 2\n  };\n  logGameState(`Player ${currentPlayer + 1} trailed a ${card.rank}`, newState);\n  return newState;\n};\n\n/**\n * Handles creating a build.\n * @param {object} gameState - The current game state.\n * @param {object} playerCard - The card played from the hand.\n * @param {Array} tableCardsInBuild - The cards from the table to include in the build.\n * @param {number} buildValue - The target value of the build.\n * @returns {object} The new game state.\n */\nexport const handleBuild = (gameState, playerCard, tableCardsInBuild, buildValue) => {\n  const {\n    playerHands,\n    tableCards,\n    currentPlayer\n  } = gameState;\n  const playerHand = playerHands[currentPlayer];\n\n  // Validation 1: Player must have a card in hand that can capture this new build.\n  // The card used for the build doesn't count.\n  const canCaptureBuild = playerHand.some(c => rankValue(c.rank) === buildValue && (c.rank !== playerCard.rank || c.suit !== playerCard.suit));\n  if (!canCaptureBuild) {\n    // This validation is now primarily handled in GameBoard.js before calling,\n    // but it's good to keep it here as a safeguard.\n    alert(`Cannot build ${buildValue}. You do not have a card of this value to capture it later.`);\n    return gameState; // Invalid build, return original state.\n  }\n  const allCardsInBuild = [playerCard, ...tableCardsInBuild];\n  allCardsInBuild.sort((a, b) => rankValue(b.rank) - rankValue(a.rank));\n  const sumOfCards = allCardsInBuild.reduce((sum, card) => sum + rankValue(card.rank), 0);\n\n  // --- NEW VALIDATION LOGIC ---\n  // A build is valid if it's a \"Sum Build\" OR a \"Set Build\".\n\n  // Condition 1: Is it a valid \"Sum Build\"?\n  const isSumBuild = sumOfCards === buildValue;\n\n  // Condition 2: Is it a valid \"Set Build\"?\n  const isSetBuild = allCardsInBuild.every(c => rankValue(c.rank) === buildValue);\n\n  // The build must be one of these types, and its value cannot exceed 10.\n  if (!isSumBuild && !isSetBuild || buildValue > 10) {\n    alert(`Invalid build. Cards do not form a valid build of ${buildValue}.`);\n    return gameState;\n  }\n  // --- END NEW VALIDATION LOGIC ---\n\n  // Create the new build object\n  const newBuild = {\n    buildId: `build-${Date.now()}-${Math.random()}`,\n    // Unique ID for the build\n    type: 'build',\n    cards: allCardsInBuild,\n    value: buildValue,\n    owner: currentPlayer\n  };\n\n  // Remove the played card from the player's hand\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === playerCard.rank && c.suit === playerCard.suit);\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  } else {\n    console.error(\"Played card not found in hand.\");\n    return gameState;\n  }\n\n  // Remove the used cards from the table\n  const tableCardIdentifiers = tableCardsInBuild.map(c => `${c.rank}-${c.suit}`);\n  const newTableCards = tableCards.filter(c => {\n    // Keep existing builds that are not part of this new build\n    if (c.type === 'build') {\n      return true;\n    }\n    // Filter out loose cards that are now in the new build\n    return !tableCardIdentifiers.includes(`${c.rank}-${c.suit}`);\n  });\n  newTableCards.push(newBuild);\n  const newState = {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    currentPlayer: (currentPlayer + 1) % 2\n  };\n  logGameState(`Player ${currentPlayer + 1} built a ${buildValue}`, newState);\n  return newState;\n};\n\n/**\n * Handles adding cards to an existing build.\n * @param {object} gameState - The current game state.\n * @param {object} playerCard - The card played from the hand.\n * @param {object} tableCard - The loose card from the table to add to the build.\n * @param {object} buildToAddTo - The build object being modified.\n * @returns {object} The new game state.\n */\nexport const handleAddToBuild = (gameState, playerCard, tableCard, buildToAddTo) => {\n  const {\n    playerHands,\n    tableCards,\n    currentPlayer\n  } = gameState;\n\n  // The new pair is added to the build.\n  const newPair = [playerCard, tableCard];\n  const newBuildCards = [...buildToAddTo.cards, ...newPair];\n  newBuildCards.sort((a, b) => rankValue(b.rank) - rankValue(a.rank));\n\n  // Create the new build object, keeping the original value and owner.\n  const newBuild = {\n    ...buildToAddTo,\n    cards: newBuildCards\n  };\n\n  // --- Update Game State ---\n\n  // 1. Remove played card from player's hand.\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === playerCard.rank && c.suit === playerCard.suit);\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  }\n\n  // 2. Remove the old build and the used loose card from the table.\n  const newTableCards = tableCards.filter(item => {\n    if (item.buildId === buildToAddTo.buildId) return false; // Remove old build\n    if (!item.type && item.rank === tableCard.rank && item.suit === tableCard.suit) return false; // Remove loose card\n    return true;\n  });\n\n  // 3. Add the new, larger build to the table.\n  newTableCards.push(newBuild);\n  const newState = {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    currentPlayer: (currentPlayer + 1) % 2\n  };\n  logGameState(`Player ${currentPlayer + 1} added to build of ${newBuild.value}`, newState);\n  return newState;\n};\n\n/**\n * Finds all valid captures for a given card.\n * @param {object} selectedCard - The card selected from the player's hand.\n * @param {Array} tableCards - The cards on the table.\n * @returns {Array} An array of valid captures.\n */\nexport const findValidCaptures = (selectedCard, tableCards) => {\n  const validCaptures = [];\n  const cardValue = selectedCard.value;\n\n  // Helper function to find combinations\n  const findCombinations = (cards, target) => {\n    const result = [];\n    const find = (startIndex, currentCombination, currentSum) => {\n      if (currentSum === target) {\n        result.push(currentCombination);\n        return;\n      }\n      if (currentSum > target) {\n        return;\n      }\n      for (let i = startIndex; i < cards.length; i++) {\n        find(i + 1, [...currentCombination, cards[i]], currentSum + cards[i].value);\n      }\n    };\n    find(0, [], 0);\n    return result;\n  };\n\n  // 1. Find all combinations of loose cards that sum up to the card value\n  const looseCards = tableCards.filter(c => c.type !== 'build');\n  const looseCardCombinations = findCombinations(looseCards, cardValue);\n  for (const combination of looseCardCombinations) {\n    validCaptures.push(combination);\n  }\n\n  // 2. Find all builds that can be captured\n  const buildCaptures = tableCards.filter(c => c.type === 'build' && c.value === cardValue);\n  for (const build of buildCaptures) {\n    validCaptures.push([build]);\n  }\n  return validCaptures;\n};\n\n/**\n * Finds all valid builds for a given card.\n * @param {object} selectedCard - The card selected from the player's hand.\n * @param {Array} tableCards - The cards on the table.\n * @returns {Array} An array of valid builds.\n */\nexport const findValidBuilds = (selectedCard, tableCards) => {\n  const validBuilds = [];\n  const cardValue = selectedCard.value;\n\n  // Helper function to find combinations\n  const findCombinations = (cards, target) => {\n    const result = [];\n    const find = (startIndex, currentCombination, currentSum) => {\n      if (currentSum === target) {\n        result.push(currentCombination);\n        return;\n      }\n      if (currentSum > target) {\n        return;\n      }\n      for (let i = startIndex; i < cards.length; i++) {\n        find(i + 1, [...currentCombination, cards[i]], currentSum + cards[i].value);\n      }\n    };\n    find(0, [], 0);\n    return result;\n  };\n\n  // Find all combinations of loose cards that sum up to the cardValue\n  const looseCards = tableCards.filter(c => c.type !== 'build');\n  const looseCardCombinations = findCombinations(looseCards, cardValue);\n  for (const combination of looseCardCombinations) {\n    validBuilds.push(combination);\n  }\n  return validBuilds;\n};\n\n/**\n * Handles capturing cards from the table.\n * @param {object} gameState - The current game state.\n * @param {object} selectedCard - The card selected from the player's hand.\n * @param {Array} selectedTableCards - The cards selected from the table to capture.\n * @returns {object} The new game state.\n */\nexport const handleCapture = (gameState, selectedCard, selectedTableCards) => {\n  const {\n    playerHands,\n    tableCards,\n    playerCaptures,\n    currentPlayer\n  } = gameState;\n\n  // Create deep copies for safe mutation\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\n  const newPlayerCaptures = JSON.parse(JSON.stringify(playerCaptures));\n\n  // Remove the selected card from the player's hand\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === selectedCard.rank && c.suit === selectedCard.suit);\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  } else {\n    console.error(\"Card to capture with not found in player's hand.\");\n    return gameState; // Card not found, abort.\n  }\n  const capturedItemsIdentifiers = new Set(selectedTableCards.map(c => c.buildId ? c.buildId : `${c.rank}-${c.suit}`));\n\n  // Remove the captured cards from the table\n  const newTableCards = tableCards.filter(item => {\n    if (item.type === 'build') {\n      // If any card of this build is in the list of cards to capture, the whole build is captured.\n      const isBuildCaptured = selectedTableCards.some(capturedItem => capturedItem.buildId === item.buildId);\n      return !isBuildCaptured; // return false (remove it) if captured\n    } else {\n      // It's a loose card.\n      return !capturedItemsIdentifiers.has(`${item.rank}-${item.suit}`);\n    }\n  });\n\n  // Add the captured cards to the player's captures\n  // The cards that form this specific capture event are grouped together.\n  const capturedGroup = [selectedCard, ...selectedTableCards.flatMap(item => item.type === 'build' ? item.cards : item)];\n  newPlayerCaptures[currentPlayer].push(capturedGroup);\n  const newState = {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    playerCaptures: newPlayerCaptures,\n    currentPlayer: (currentPlayer + 1) % 2\n  };\n  logGameState(`Player ${currentPlayer + 1} captured with a ${selectedCard.rank}`, newState);\n  return newState;\n};\n\n/**\n * Calculates the scores for each player.\n * @param {Array} playerCaptures - An array of captured cards for each player.\n * @returns {Array} An array of scores for each player.\n */\nexport const calculateScores = playerCaptures => {\n  const scores = [0, 0];\n\n  // Flatten the captured groups for each player to get a simple list of cards for scoring\n  const flatPlayerCaptures = playerCaptures.map(captureGroups => captureGroups.flat());\n  flatPlayerCaptures.forEach((captures, playerIndex) => {\n    let score = 0;\n    for (const card of captures) {\n      if (card.rank === 'A') {\n        score += 1;\n      } else if (card.rank === '10' && card.suit === '♦') {\n        score += 2;\n      } else if (card.rank === '2' && card.suit === '♠') {\n        score += 1;\n      }\n    }\n    scores[playerIndex] = score;\n  });\n\n  // Add bonus points for the player with the most cards\n  if (flatPlayerCaptures[0].length > flatPlayerCaptures[1].length) {\n    scores[0] += 3;\n  } else if (flatPlayerCaptures[1].length > flatPlayerCaptures[0].length) {\n    scores[1] += 3;\n  }\n  return scores;\n};\n\n/**\n * Checks if the round is over.\n * @param {object} gameState - The current game state.\n * @returns {boolean} True if the round is over, false otherwise.\n */\nexport const isRoundOver = gameState => {\n  return gameState.playerHands.every(hand => hand.length === 0);\n};\n\n/**\n * Checks if the game is over.\n * @param {object} gameState - The current game state.\n * @returns {boolean} True if the game is over, false otherwise.\n */\nexport const isGameOver = gameState => {\n  return gameState.round === 2 && isRoundOver(gameState);\n};","map":{"version":3,"names":["initializeGame","suits","ranks","deck","suit","rank","push","value","rankValue","shuffleDeck","playerHands","i","pop","tableCards","playerCaptures","currentPlayer","round","scores","gameOver","winner","length","j","Math","floor","random","parseInt","logGameState","moveDescription","gameState","console","group","log","JSON","parse","stringify","groupEnd","handleTrail","card","playerOwnsBuild","some","c","type","owner","alert","looseCardRanks","filter","map","includes","newPlayerHands","hand","cardIndex","findIndex","splice","error","newState","handleBuild","playerCard","tableCardsInBuild","buildValue","playerHand","canCaptureBuild","allCardsInBuild","sort","a","b","sumOfCards","reduce","sum","isSumBuild","isSetBuild","every","newBuild","buildId","Date","now","cards","tableCardIdentifiers","newTableCards","handleAddToBuild","tableCard","buildToAddTo","newPair","newBuildCards","item","findValidCaptures","selectedCard","validCaptures","cardValue","findCombinations","target","result","find","startIndex","currentCombination","currentSum","looseCards","looseCardCombinations","combination","buildCaptures","build","findValidBuilds","validBuilds","handleCapture","selectedTableCards","newPlayerCaptures","capturedItemsIdentifiers","Set","isBuildCaptured","capturedItem","has","capturedGroup","flatMap","calculateScores","flatPlayerCaptures","captureGroups","flat","forEach","captures","playerIndex","score","isRoundOver","isGameOver"],"sources":["C:/Users/LB/Desktop/Linda Baloyi/casino/src/src/components/game-logic.js"],"sourcesContent":["\n// src/components/game-logic.js\n\n/**\n * Initializes the game state, including shuffling the deck and dealing cards.\n * @returns {object} The initial game state.\n */\nexport const initializeGame = () => {\n  const suits = ['♠', '♥', '♦', '♣'];\n  const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10'];\n  let deck = [];\n\n  for (const suit of suits) {\n    for (const rank of ranks) {\n      deck.push({ suit, rank, value: rankValue(rank) });\n    }\n  }\n\n  deck = shuffleDeck(deck);\n\n  const playerHands = [[], []];\n  for (let i = 0; i < 10; i++) {\n    playerHands[0].push(deck.pop());\n    playerHands[1].push(deck.pop());\n  }\n\n  return {\n    deck,\n    playerHands,\n    tableCards: [],\n    playerCaptures: [[], []],\n    currentPlayer: 0,\n    round: 1,\n    scores: [0, 0],\n    gameOver: false,\n    winner: null,\n  };\n};\n\n/**\n * Shuffles the deck of cards.\n * @param {Array} deck - The deck to shuffle.\n * @returns {Array} The shuffled deck.\n */\nexport const shuffleDeck = (deck) => {\n  for (let i = deck.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [deck[i], deck[j]] = [deck[j], deck[i]];\n  }\n  return deck;\n};\n\n/**\n * Converts a card's rank to its numeric value.\n * @param {string} rank - The rank of the card (e.g., 'A', '5', 'K').\n * @returns {number} The numeric value of the rank.\n */\nexport const rankValue = (rank) => {\n  if (rank === 'A') return 1;\n  if (rank === 'J') return 11;\n  if (rank === 'Q') return 12;\n  if (rank === 'K') return 13;\n  return parseInt(rank, 10);\n};\n\n/**\n * Logs the current state of the game for debugging purposes.\n * @param {string} moveDescription - A description of the move that just occurred.\n * @param {object} gameState - The game state to log.\n */\nconst logGameState = (moveDescription, gameState) => {\n  // Using console.group to create collapsible log groups for better readability\n  console.group(`%cMove: ${moveDescription}`, 'color: blue; font-weight: bold;');\n  console.log('Table Cards:', JSON.parse(JSON.stringify(gameState.tableCards)));\n  console.log('Player 1 Hand:', JSON.parse(JSON.stringify(gameState.playerHands[0])));\n  console.log('Player 2 Hand:', JSON.parse(JSON.stringify(gameState.playerHands[1])));\n  console.log('Player 1 Captures:', JSON.parse(JSON.stringify(gameState.playerCaptures[0])));\n  console.log('Player 2 Captures:', JSON.parse(JSON.stringify(gameState.playerCaptures[1])));\n  console.log(`Next turn: Player ${gameState.currentPlayer + 1}`);\n  console.groupEnd();\n};\n\n/**\n * Handles trailing a card to the table.\n * @param {object} gameState - The current game state.\n * @param {object} card - The card to trail.\n * @returns {object} The new game state.\n */\nexport const handleTrail = (gameState, card) => {\n  const { playerHands, tableCards, currentPlayer, round } = gameState;\n\n  // New Rule: In round 1, a player cannot trail if they own a build.\n  if (round === 1) {\n    const playerOwnsBuild = tableCards.some(\n      (c) => c.type === 'build' && c.owner === currentPlayer\n    );\n    if (playerOwnsBuild) {\n      alert(\"You cannot trail a card while you own a build in the first round. You must capture or build.\");\n      return gameState; // Invalid move\n    }\n  }\n\n  // Rule: You cannot trail a card if a loose card of the same rank is on the table.\n  const looseCardRanks = tableCards\n    .filter(c => !c.type) // Only check loose cards, not builds\n    .map(c => c.rank);\n\n  if (looseCardRanks.includes(card.rank)) {\n    alert(`You cannot trail a ${card.rank} because one is already on the table.`);\n    return gameState; // Invalid move, return original state.\n  }\n\n  // Remove the card from the player's hand\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === card.rank && c.suit === card.suit);\n\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  } else {\n    console.error(\"Card to trail not found in player's hand.\");\n    return gameState; // Card not found, abort.\n  }\n\n  const newState = {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: [...tableCards, card],\n    currentPlayer: (currentPlayer + 1) % 2,\n  };\n\n  logGameState(`Player ${currentPlayer + 1} trailed a ${card.rank}`, newState);\n  return newState;\n};\n\n/**\n * Handles creating a build.\n * @param {object} gameState - The current game state.\n * @param {object} playerCard - The card played from the hand.\n * @param {Array} tableCardsInBuild - The cards from the table to include in the build.\n * @param {number} buildValue - The target value of the build.\n * @returns {object} The new game state.\n */\nexport const handleBuild = (gameState, playerCard, tableCardsInBuild, buildValue) => {\n  const { playerHands, tableCards, currentPlayer } = gameState;\n  const playerHand = playerHands[currentPlayer];\n\n  // Validation 1: Player must have a card in hand that can capture this new build.\n  // The card used for the build doesn't count.\n  const canCaptureBuild = playerHand.some(\n    c => rankValue(c.rank) === buildValue && (c.rank !== playerCard.rank || c.suit !== playerCard.suit)\n  );\n  if (!canCaptureBuild) {\n    // This validation is now primarily handled in GameBoard.js before calling,\n    // but it's good to keep it here as a safeguard.\n    alert(`Cannot build ${buildValue}. You do not have a card of this value to capture it later.`);\n    return gameState; // Invalid build, return original state.\n  }\n\n  const allCardsInBuild = [playerCard, ...tableCardsInBuild];\n  allCardsInBuild.sort((a, b) => rankValue(b.rank) - rankValue(a.rank));\n  const sumOfCards = allCardsInBuild.reduce((sum, card) => sum + rankValue(card.rank), 0);\n\n  // --- NEW VALIDATION LOGIC ---\n  // A build is valid if it's a \"Sum Build\" OR a \"Set Build\".\n\n  // Condition 1: Is it a valid \"Sum Build\"?\n  const isSumBuild = sumOfCards === buildValue;\n\n  // Condition 2: Is it a valid \"Set Build\"?\n  const isSetBuild = allCardsInBuild.every(c => rankValue(c.rank) === buildValue);\n\n  // The build must be one of these types, and its value cannot exceed 10.\n  if ((!isSumBuild && !isSetBuild) || buildValue > 10) {\n    alert(`Invalid build. Cards do not form a valid build of ${buildValue}.`);\n    return gameState;\n  }\n  // --- END NEW VALIDATION LOGIC ---\n\n  // Create the new build object\n  const newBuild = {\n    buildId: `build-${Date.now()}-${Math.random()}`, // Unique ID for the build\n    type: 'build',\n    cards: allCardsInBuild,\n    value: buildValue,\n    owner: currentPlayer,\n  };\n\n  // Remove the played card from the player's hand\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === playerCard.rank && c.suit === playerCard.suit);\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  } else {\n    console.error(\"Played card not found in hand.\");\n    return gameState;\n  }\n\n  // Remove the used cards from the table\n  const tableCardIdentifiers = tableCardsInBuild.map(c => `${c.rank}-${c.suit}`);\n  const newTableCards = tableCards.filter(c => {\n    // Keep existing builds that are not part of this new build\n    if (c.type === 'build') {\n      return true;\n    }\n    // Filter out loose cards that are now in the new build\n    return !tableCardIdentifiers.includes(`${c.rank}-${c.suit}`);\n  });\n  newTableCards.push(newBuild);\n\n  const newState = {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    currentPlayer: (currentPlayer + 1) % 2,\n  };\n\n  logGameState(`Player ${currentPlayer + 1} built a ${buildValue}`, newState);\n  return newState;\n};\n\n/**\n * Handles adding cards to an existing build.\n * @param {object} gameState - The current game state.\n * @param {object} playerCard - The card played from the hand.\n * @param {object} tableCard - The loose card from the table to add to the build.\n * @param {object} buildToAddTo - The build object being modified.\n * @returns {object} The new game state.\n */\nexport const handleAddToBuild = (gameState, playerCard, tableCard, buildToAddTo) => {\n  const { playerHands, tableCards, currentPlayer } = gameState;\n\n  // The new pair is added to the build.\n  const newPair = [playerCard, tableCard];\n  const newBuildCards = [...buildToAddTo.cards, ...newPair];\n  newBuildCards.sort((a, b) => rankValue(b.rank) - rankValue(a.rank));\n\n  // Create the new build object, keeping the original value and owner.\n  const newBuild = {\n    ...buildToAddTo,\n    cards: newBuildCards,\n  };\n\n  // --- Update Game State ---\n\n  // 1. Remove played card from player's hand.\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === playerCard.rank && c.suit === playerCard.suit);\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  }\n\n  // 2. Remove the old build and the used loose card from the table.\n  const newTableCards = tableCards.filter(item => {\n    if (item.buildId === buildToAddTo.buildId) return false; // Remove old build\n    if (!item.type && item.rank === tableCard.rank && item.suit === tableCard.suit) return false; // Remove loose card\n    return true;\n  });\n\n  // 3. Add the new, larger build to the table.\n  newTableCards.push(newBuild);\n\n  const newState = {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    currentPlayer: (currentPlayer + 1) % 2,\n  };\n  logGameState(`Player ${currentPlayer + 1} added to build of ${newBuild.value}`, newState);\n  return newState;\n};\n\n/**\n * Finds all valid captures for a given card.\n * @param {object} selectedCard - The card selected from the player's hand.\n * @param {Array} tableCards - The cards on the table.\n * @returns {Array} An array of valid captures.\n */\nexport const findValidCaptures = (selectedCard, tableCards) => {\n  const validCaptures = [];\n  const cardValue = selectedCard.value;\n\n  // Helper function to find combinations\n  const findCombinations = (cards, target) => {\n    const result = [];\n    const find = (startIndex, currentCombination, currentSum) => {\n      if (currentSum === target) {\n        result.push(currentCombination);\n        return;\n      }\n      if (currentSum > target) {\n        return;\n      }\n      for (let i = startIndex; i < cards.length; i++) {\n        find(i + 1, [...currentCombination, cards[i]], currentSum + cards[i].value);\n      }\n    };\n    find(0, [], 0);\n    return result;\n  };\n\n  // 1. Find all combinations of loose cards that sum up to the card value\n  const looseCards = tableCards.filter((c) => c.type !== 'build');\n  const looseCardCombinations = findCombinations(looseCards, cardValue);\n  for (const combination of looseCardCombinations) {\n    validCaptures.push(combination);\n  }\n\n  // 2. Find all builds that can be captured\n  const buildCaptures = tableCards.filter((c) => c.type === 'build' && c.value === cardValue);\n  for (const build of buildCaptures) {\n    validCaptures.push([build]);\n  }\n\n  return validCaptures;\n};\n\n/**\n * Finds all valid builds for a given card.\n * @param {object} selectedCard - The card selected from the player's hand.\n * @param {Array} tableCards - The cards on the table.\n * @returns {Array} An array of valid builds.\n */\nexport const findValidBuilds = (selectedCard, tableCards) => {\n  const validBuilds = [];\n  const cardValue = selectedCard.value;\n\n  // Helper function to find combinations\n  const findCombinations = (cards, target) => {\n    const result = [];\n    const find = (startIndex, currentCombination, currentSum) => {\n      if (currentSum === target) {\n        result.push(currentCombination);\n        return;\n      }\n      if (currentSum > target) {\n        return;\n      }\n      for (let i = startIndex; i < cards.length; i++) {\n        find(i + 1, [...currentCombination, cards[i]], currentSum + cards[i].value);\n      }\n    };\n    find(0, [], 0);\n    return result;\n  };\n\n  // Find all combinations of loose cards that sum up to the cardValue\n  const looseCards = tableCards.filter((c) => c.type !== 'build');\n  const looseCardCombinations = findCombinations(looseCards, cardValue);\n  for (const combination of looseCardCombinations) {\n    validBuilds.push(combination);\n  }\n\n  return validBuilds;\n};\n\n/**\n * Handles capturing cards from the table.\n * @param {object} gameState - The current game state.\n * @param {object} selectedCard - The card selected from the player's hand.\n * @param {Array} selectedTableCards - The cards selected from the table to capture.\n * @returns {object} The new game state.\n */\nexport const handleCapture = (gameState, selectedCard, selectedTableCards) => {\n  const { playerHands, tableCards, playerCaptures, currentPlayer } = gameState;\n\n  // Create deep copies for safe mutation\n  const newPlayerHands = JSON.parse(JSON.stringify(playerHands));\n  const newPlayerCaptures = JSON.parse(JSON.stringify(playerCaptures));\n\n  // Remove the selected card from the player's hand\n  const hand = newPlayerHands[currentPlayer];\n  const cardIndex = hand.findIndex(c => c.rank === selectedCard.rank && c.suit === selectedCard.suit);\n\n  if (cardIndex > -1) {\n    hand.splice(cardIndex, 1);\n  } else {\n    console.error(\"Card to capture with not found in player's hand.\");\n    return gameState; // Card not found, abort.\n  }\n\n  const capturedItemsIdentifiers = new Set(selectedTableCards.map(c => c.buildId ? c.buildId : `${c.rank}-${c.suit}`));\n\n  // Remove the captured cards from the table\n  const newTableCards = tableCards.filter(item => {\n    if (item.type === 'build') {\n      // If any card of this build is in the list of cards to capture, the whole build is captured.\n      const isBuildCaptured = selectedTableCards.some(capturedItem => capturedItem.buildId === item.buildId);\n      return !isBuildCaptured; // return false (remove it) if captured\n    } else {\n      // It's a loose card.\n      return !capturedItemsIdentifiers.has(`${item.rank}-${item.suit}`);\n    }\n  });\n\n  // Add the captured cards to the player's captures\n  // The cards that form this specific capture event are grouped together.\n  const capturedGroup = [selectedCard, ...selectedTableCards.flatMap(item => item.type === 'build' ? item.cards : item)];\n  newPlayerCaptures[currentPlayer].push(capturedGroup);\n\n  const newState = {\n    ...gameState,\n    playerHands: newPlayerHands,\n    tableCards: newTableCards,\n    playerCaptures: newPlayerCaptures,\n    currentPlayer: (currentPlayer + 1) % 2,\n  };\n\n  logGameState(`Player ${currentPlayer + 1} captured with a ${selectedCard.rank}`, newState);\n  return newState;\n};\n\n/**\n * Calculates the scores for each player.\n * @param {Array} playerCaptures - An array of captured cards for each player.\n * @returns {Array} An array of scores for each player.\n */\nexport const calculateScores = (playerCaptures) => {\n  const scores = [0, 0];\n\n  // Flatten the captured groups for each player to get a simple list of cards for scoring\n  const flatPlayerCaptures = playerCaptures.map(captureGroups => captureGroups.flat());\n\n  flatPlayerCaptures.forEach((captures, playerIndex) => {\n    let score = 0;\n    for (const card of captures) {\n      if (card.rank === 'A') {\n        score += 1;\n      } else if (card.rank === '10' && card.suit === '♦') {\n        score += 2;\n      } else if (card.rank === '2' && card.suit === '♠') {\n        score += 1;\n      }\n    }\n    scores[playerIndex] = score;\n  });\n\n  // Add bonus points for the player with the most cards\n  if (flatPlayerCaptures[0].length > flatPlayerCaptures[1].length) {\n    scores[0] += 3;\n  } else if (flatPlayerCaptures[1].length > flatPlayerCaptures[0].length) {\n    scores[1] += 3;\n  }\n\n  return scores;\n};\n\n/**\n * Checks if the round is over.\n * @param {object} gameState - The current game state.\n * @returns {boolean} True if the round is over, false otherwise.\n */\nexport const isRoundOver = (gameState) => {\n  return gameState.playerHands.every((hand) => hand.length === 0);\n};\n\n/**\n * Checks if the game is over.\n * @param {object} gameState - The current game state.\n * @returns {boolean} True if the game is over, false otherwise.\n */\nexport const isGameOver = (gameState) => {\n  return gameState.round === 2 && isRoundOver(gameState);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}